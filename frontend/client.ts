/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "{protocol}://api.domain-name.ru";
    }

    /**
     * регистрация пользователя в системе
     * @param body (optional) 
     * @return OK
     */
    signup(body: Body | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignup(_response);
        });
    }

    protected processSignup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438, \u0442\u0430\u043a\u043e\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0443\u0436\u0435 \u0435\u0441\u0442\u044c", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * авторизация пользователя в системе
     * @param body (optional) 
     * @return OK
     */
    login(body: Body2 | undefined): Promise<Anonymous> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438, \u0442\u0430\u043a\u043e\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0443\u0436\u0435 \u0435\u0441\u0442\u044c", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * выход из системы
     * @return OK
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * обновления тоукена доступа
     * @param body (optional) 
     * @return OK
     */
    refreshtoken(body: Body3 | undefined): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/auth/refreshtoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshtoken(_response);
        });
    }

    protected processRefreshtoken(response: Response): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous2.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 Refresh Token", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * сброс пароля на почту или на телефон пользователя
     * @param body (optional) 
     * @return OK
     */
    reset(body: Body4 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReset(_response);
        });
    }

    protected processReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438, \u0442\u0430\u043a\u043e\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0443\u0436\u0435 \u0435\u0441\u0442\u044c", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * сохранение пароля после сброса
     * @param body (optional) 
     * @return OK
     */
    save(body: Body5 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/reset/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0442\u043e\u043a\u0435\u043d\u0430", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * смена пароля
     * @param body (optional) 
     * @return OK
     */
    update(body: Body6 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/reset/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430 \u0441\u0442\u0430\u0440\u043e\u0433\u043e \u043f\u0430\u0440\u043e\u043b\u044f", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Получаем адрес по координатам
     * @param body (optional) 
     * @return OK
     */
    address(body: Body7 | undefined): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/services/address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddress(_response);
        });
    }

    protected processAddress(response: Response): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous3.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Получаем координаты по адресу
     * @param body (optional) 
     * @return OK
     */
    coords(body: Body8 | undefined): Promise<Anonymous4> {
        let url_ = this.baseUrl + "/services/coords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCoords(_response);
        });
    }

    protected processCoords(response: Response): Promise<Anonymous4> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous4.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * оповещение пользователей
     * @param title (optional) 
     * @param message (optional) 
     * @param level (optional) 
     * @param type (optional) 
     * @param send_as (optional) 
     * @param user_ids (optional) 
     * @param category (optional) 
     * @param filenames (optional) 
     * @return OK
     */
    mailingPOST(title: string | undefined, message: string | undefined, level: Level | undefined, type: Type | undefined, send_as: Send_as | undefined, user_ids: number[] | undefined, category: Category | undefined, filenames: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/services/mailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title === null || title === undefined)
            throw new Error("The parameter 'title' cannot be null.");
        else
            content_.append("title", title.toString());
        if (message === null || message === undefined)
            throw new Error("The parameter 'message' cannot be null.");
        else
            content_.append("message", message.toString());
        if (level === null || level === undefined)
            throw new Error("The parameter 'level' cannot be null.");
        else
            content_.append("level", level.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("type", type.toString());
        if (send_as === null || send_as === undefined)
            throw new Error("The parameter 'send_as' cannot be null.");
        else
            content_.append("send_as", send_as.toString());
        if (user_ids === null || user_ids === undefined)
            throw new Error("The parameter 'user_ids' cannot be null.");
        else
            user_ids.forEach(item_ => content_.append("user_ids", item_.toString()));
        if (category === null || category === undefined)
            throw new Error("The parameter 'category' cannot be null.");
        else
            content_.append("category", category.toString());
        if (filenames === null || filenames === undefined)
            throw new Error("The parameter 'filenames' cannot be null.");
        else
            filenames.forEach(item_ => content_.append("filenames", item_.data, item_.fileName ? item_.fileName : "filenames") );

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailingPOST(_response);
        });
    }

    protected processMailingPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * статистика по категориям за период
     * @param body (optional) 
     * @return OK
     */
    statistic(body: Body9 | undefined): Promise<Anonymous5> {
        let url_ = this.baseUrl + "/services/statistic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatistic(_response);
        });
    }

    protected processStatistic(response: Response): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous5.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * тепловая карта проблемных \ решенных зон за период
     * @param body (optional) 
     * @return OK
     */
    heatmap(body: Body10 | undefined): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/services/heatmap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHeatmap(_response);
        });
    }

    protected processHeatmap(response: Response): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous6.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * импортирование заявок в формате Excel-файла(ов)
     * @param filenames (optional) 
     * @return OK
     */
    import(filenames: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/services/request/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filenames === null || filenames === undefined)
            throw new Error("The parameter 'filenames' cannot be null.");
        else
            filenames.forEach(item_ => content_.append("filenames", item_.data, item_.fileName ? item_.fileName : "filenames") );

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * экспортирование заявок в формате Excel-файла
     * @param body (optional) 
     * @return OK
     */
    export(body: Body11 | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/services/request/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/binary"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим пользователя по идентификатору
     * @param userId Целочисленный идентификатор пользователя
     * @return OK
     */
    usersGET(userId: number): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем пользователя по идентификатору
     * @param userId Целочисленный идентификатор пользователя
     * @param body (optional) 
     * @return OK
     */
    usersPUT(userId: number, body: UserForm | undefined): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем пользователя по идентификатору
     * @param userId Parameter description in CommonMark or HTML.
     * @return OK
     */
    usersDELETE(userId: number): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * возвращаем текущего пользователя
     * @return OK
     */
    me(): Promise<User> {
        let url_ = this.baseUrl + "/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим профиль пользователя по идентификатору пользователя
     * @param userId Целочисленный идентификатор пользователя
     * @return OK
     */
    profile(userId: number): Promise<Profile> {
        let url_ = this.baseUrl + "/users/{userId}/profile";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfile(_response);
        });
    }

    protected processProfile(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список пользователей
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    usersGET2(page: number | undefined, size: number | undefined): Promise<Anonymous7> {
        let url_ = this.baseUrl + "/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET2(_response);
        });
    }

    protected processUsersGET2(response: Response): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем пользователя
     * @param body (optional) 
     * @return OK
     */
    usersPOST(body: UserForm | undefined): Promise<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем роли пользователя
     * @param userId Целочисленный идентификатор пользователя
     * @param body (optional) 
     * @return OK
     */
    rolesPUT(userId: number, body: Body12 | undefined): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesPUT(_response);
        });
    }

    protected processRolesPUT(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * блокируем пользователя по идентификатору
     * @param userId Целочисленный идентификатор пользователя
     * @return OK
     */
    blocked(userId: number): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}/blocked";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlocked(_response);
        });
    }

    protected processBlocked(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * разблокируем пользователя по идентификатору
     * @param userId Целочисленный идентификатор пользователя
     * @return OK
     */
    unblocked(userId: number): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}/unblocked";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnblocked(_response);
        });
    }

    protected processUnblocked(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим профиль пользователя по идентификатору
     * @param profileId Целочисленный идентификатор профиля пользователя
     * @return OK
     */
    profilesGET(profileId: number): Promise<Profile> {
        let url_ = this.baseUrl + "/profiles/{profileId}";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilesGET(_response);
        });
    }

    protected processProfilesGET(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем профиль пользователя по идентификатору
     * @param profileId Целочисленный идентификатор профиля пользователя
     * @param body (optional) 
     * @return OK
     */
    profilesPUT(profileId: number, body: ProfileForm | undefined): Promise<Profile> {
        let url_ = this.baseUrl + "/profiles/{profileId}";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilesPUT(_response);
        });
    }

    protected processProfilesPUT(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем пользователя по идентификатору
     * @param profileId Parameter description in CommonMark or HTML.
     * @return OK
     */
    profilesDELETE(profileId: number): Promise<Profile> {
        let url_ = this.baseUrl + "/profiles/{profileId}";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilesDELETE(_response);
        });
    }

    protected processProfilesDELETE(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список профилей пользователя
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    profilesGET2(page: number | undefined, size: number | undefined): Promise<Anonymous8> {
        let url_ = this.baseUrl + "/profiles?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilesGET2(_response);
        });
    }

    protected processProfilesGET2(response: Response): Promise<Anonymous8> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем профиль
     * @param body (optional) 
     * @return OK
     */
    profilesPOST(body: ProfileForm | undefined): Promise<Profile> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilesPOST(_response);
        });
    }

    protected processProfilesPOST(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим категорию по идентификатору
     * @param problemCategoryId Целочисленный идентификатор категории
     * @return OK
     */
    problemCategoriesGET(problemCategoryId: number): Promise<User> {
        let url_ = this.baseUrl + "/problem-categories/{problemCategoryId}";
        if (problemCategoryId === undefined || problemCategoryId === null)
            throw new Error("The parameter 'problemCategoryId' must be defined.");
        url_ = url_.replace("{problemCategoryId}", encodeURIComponent("" + problemCategoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProblemCategoriesGET(_response);
        });
    }

    protected processProblemCategoriesGET(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем категорию по идентификатору
     * @param problemCategoryId Целочисленный идентификатор категории
     * @param body (optional) 
     * @return OK
     */
    problemCategoriesPUT(problemCategoryId: number, body: ProblemCategoryForm | undefined): Promise<ProblemCategory> {
        let url_ = this.baseUrl + "/problem-categories/{problemCategoryId}";
        if (problemCategoryId === undefined || problemCategoryId === null)
            throw new Error("The parameter 'problemCategoryId' must be defined.");
        url_ = url_.replace("{problemCategoryId}", encodeURIComponent("" + problemCategoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProblemCategoriesPUT(_response);
        });
    }

    protected processProblemCategoriesPUT(response: Response): Promise<ProblemCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProblemCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем категорию по идентификатору
     * @param problemCategoryId Parameter description in CommonMark or HTML.
     * @return OK
     */
    problemCategoriesDELETE(problemCategoryId: number): Promise<ProblemCategory> {
        let url_ = this.baseUrl + "/problem-categories/{problemCategoryId}";
        if (problemCategoryId === undefined || problemCategoryId === null)
            throw new Error("The parameter 'problemCategoryId' must be defined.");
        url_ = url_.replace("{problemCategoryId}", encodeURIComponent("" + problemCategoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProblemCategoriesDELETE(_response);
        });
    }

    protected processProblemCategoriesDELETE(response: Response): Promise<ProblemCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProblemCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список категорий проблем
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    problemCategoriesGET2(page: number | undefined, size: number | undefined): Promise<Anonymous9> {
        let url_ = this.baseUrl + "/problem-categories?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProblemCategoriesGET2(_response);
        });
    }

    protected processProblemCategoriesGET2(response: Response): Promise<Anonymous9> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем новую категорию проблем
     * @param body (optional) 
     * @return OK
     */
    problemCategoriesPOST(body: ProblemCategoryForm | undefined): Promise<ProblemCategory> {
        let url_ = this.baseUrl + "/problem-categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProblemCategoriesPOST(_response);
        });
    }

    protected processProblemCategoriesPOST(response: Response): Promise<ProblemCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProblemCategory.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список активных запросов в категории
     * @param problemCategoryId Целочисленный идентификатор категории
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    activeRequests(problemCategoryId: number, page: number | undefined, size: number | undefined): Promise<Anonymous10> {
        let url_ = this.baseUrl + "/problem-categories/{problemCategoryId}/active-requests?";
        if (problemCategoryId === undefined || problemCategoryId === null)
            throw new Error("The parameter 'problemCategoryId' must be defined.");
        url_ = url_.replace("{problemCategoryId}", encodeURIComponent("" + problemCategoryId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActiveRequests(_response);
        });
    }

    protected processActiveRequests(response: Response): Promise<Anonymous10> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список выполненных запросов в категории
     * @param problemCategoryId Целочисленный идентификатор категории
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    completedRequests(problemCategoryId: number, page: number | undefined, size: number | undefined): Promise<Anonymous11> {
        let url_ = this.baseUrl + "/problem-categories/{problemCategoryId}/completed-requests?";
        if (problemCategoryId === undefined || problemCategoryId === null)
            throw new Error("The parameter 'problemCategoryId' must be defined.");
        url_ = url_.replace("{problemCategoryId}", encodeURIComponent("" + problemCategoryId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompletedRequests(_response);
        });
    }

    protected processCompletedRequests(response: Response): Promise<Anonymous11> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список архивных запросов в категории
     * @param problemCategoryId Целочисленный идентификатор категории
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    archiveRequests(problemCategoryId: number, page: number | undefined, size: number | undefined): Promise<Anonymous12> {
        let url_ = this.baseUrl + "/problem-categories/{problemCategoryId}/archive-requests?";
        if (problemCategoryId === undefined || problemCategoryId === null)
            throw new Error("The parameter 'problemCategoryId' must be defined.");
        url_ = url_.replace("{problemCategoryId}", encodeURIComponent("" + problemCategoryId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchiveRequests(_response);
        });
    }

    protected processArchiveRequests(response: Response): Promise<Anonymous12> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим заявку по идентификатору
     * @param requestId Целочисленный идентификатор заявки
     * @return OK
     */
    requestsGET(requestId: number): Promise<Request> {
        let url_ = this.baseUrl + "/requests/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsGET(_response);
        });
    }

    protected processRequestsGET(response: Response): Promise<Request> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем заявку по идентификатору
     * @param requestId Целочисленный идентификатор заявки
     * @param body (optional) 
     * @return OK
     */
    requestsPUT(requestId: number, body: Blob | undefined): Promise<Request> {
        let url_ = this.baseUrl + "/requests/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "multipart/form-data",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsPUT(_response);
        });
    }

    protected processRequestsPUT(response: Response): Promise<Request> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем заявку по идентификатору
     * @param requestId Parameter description in CommonMark or HTML.
     * @return OK
     */
    requestsDELETE(requestId: number): Promise<Request> {
        let url_ = this.baseUrl + "/requests/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsDELETE(_response);
        });
    }

    protected processRequestsDELETE(response: Response): Promise<Request> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список заявок
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    requestsGET2(page: number | undefined, size: number | undefined): Promise<Anonymous13> {
        let url_ = this.baseUrl + "/requests?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsGET2(_response);
        });
    }

    protected processRequestsGET2(response: Response): Promise<Anonymous13> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем заявку
     * @param body (optional) 
     * @return OK
     */
    requestsPOST(body: Blob | undefined): Promise<Request> {
        let url_ = this.baseUrl + "/requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "multipart/form-data",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsPOST(_response);
        });
    }

    protected processRequestsPOST(response: Response): Promise<Request> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Подбор заявок в радиусе
     * @param body (optional) 
     * @return OK
     */
    inRange(body: Body13 | undefined): Promise<Request[]> {
        let url_ = this.baseUrl + "/requests/in-range";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInRange(_response);
        });
    }

    protected processInRange(response: Response): Promise<Request[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * модификация рейтинга заявки (+-)
     * @param body (optional) 
     * @return OK
     */
    rating(body: Body14 | undefined): Promise<Request[]> {
        let url_ = this.baseUrl + "/requests/rating";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRating(_response);
        });
    }

    protected processRating(response: Response): Promise<Request[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * формируем заявку в виде pdf
     * @param requestId Целочисленный идентификатор заявки
     * @return OK
     */
    pdf(requestId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/requests/{requestId}/pdf";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/pdf"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPdf(_response);
        });
    }

    protected processPdf(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * отмечаем просмотр заявки по идентификатору для текущего авторизованного пользователя
     * @param requestId Целочисленный идентификатор заявки
     * @return OK
     */
    watch(requestId: number): Promise<void> {
        let url_ = this.baseUrl + "/requests/{requestId}/watch";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWatch(_response);
        });
    }

    protected processWatch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u0430\u044f \u0437\u0430\u044f\u0432\u043a\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим исполнителя по идентификатору
     * @param contractorId Целочисленный идентификатор
     * @return OK
     */
    contractorsGET(contractorId: number): Promise<Contractor> {
        let url_ = this.baseUrl + "/contractors/{contractorId}";
        if (contractorId === undefined || contractorId === null)
            throw new Error("The parameter 'contractorId' must be defined.");
        url_ = url_.replace("{contractorId}", encodeURIComponent("" + contractorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContractorsGET(_response);
        });
    }

    protected processContractorsGET(response: Response): Promise<Contractor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contractor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем исполнителя по идентификатору
     * @param contractorId Целочисленный идентификатор исполнителя
     * @param body (optional) 
     * @return OK
     */
    contractorsPUT(contractorId: number, body: ContractorForm | undefined): Promise<Contractor> {
        let url_ = this.baseUrl + "/contractors/{contractorId}";
        if (contractorId === undefined || contractorId === null)
            throw new Error("The parameter 'contractorId' must be defined.");
        url_ = url_.replace("{contractorId}", encodeURIComponent("" + contractorId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContractorsPUT(_response);
        });
    }

    protected processContractorsPUT(response: Response): Promise<Contractor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contractor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем исполнителя по идентификатору
     * @param contractorId Parameter description in CommonMark or HTML.
     * @return OK
     */
    contractorsDELETE(contractorId: number): Promise<Contractor> {
        let url_ = this.baseUrl + "/contractors/{contractorId}";
        if (contractorId === undefined || contractorId === null)
            throw new Error("The parameter 'contractorId' must be defined.");
        url_ = url_.replace("{contractorId}", encodeURIComponent("" + contractorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContractorsDELETE(_response);
        });
    }

    protected processContractorsDELETE(response: Response): Promise<Contractor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contractor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список архивных заявок по исполнительному органу
     * @param contractorId Целочисленный идентификатор
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    archive(contractorId: number, page: number | undefined, size: number | undefined): Promise<Anonymous14> {
        let url_ = this.baseUrl + "/contractors/{contractorId}/requests/archive?";
        if (contractorId === undefined || contractorId === null)
            throw new Error("The parameter 'contractorId' must be defined.");
        url_ = url_.replace("{contractorId}", encodeURIComponent("" + contractorId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchive(_response);
        });
    }

    protected processArchive(response: Response): Promise<Anonymous14> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список активных заявок по исполнительному органу
     * @param contractorId Целочисленный идентификатор
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    active(contractorId: number, page: number | undefined, size: number | undefined): Promise<Anonymous15> {
        let url_ = this.baseUrl + "/contractors/{contractorId}/requests/active?";
        if (contractorId === undefined || contractorId === null)
            throw new Error("The parameter 'contractorId' must be defined.");
        url_ = url_.replace("{contractorId}", encodeURIComponent("" + contractorId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActive(_response);
        });
    }

    protected processActive(response: Response): Promise<Anonymous15> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим активные задачи для выбранного исполнительного \ контролирующего органа
     * @param contractorId Целочисленный идентификатор
     * @return OK
     */
    tasksGET(contractorId: number): Promise<ContractorTask> {
        let url_ = this.baseUrl + "/contractors/{contractorId}/tasks";
        if (contractorId === undefined || contractorId === null)
            throw new Error("The parameter 'contractorId' must be defined.");
        url_ = url_.replace("{contractorId}", encodeURIComponent("" + contractorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksGET(_response);
        });
    }

    protected processTasksGET(response: Response): Promise<ContractorTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список профилей исполнительных органов
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    contractorsGET2(page: number | undefined, size: number | undefined): Promise<Anonymous16> {
        let url_ = this.baseUrl + "/contractors?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContractorsGET2(_response);
        });
    }

    protected processContractorsGET2(response: Response): Promise<Anonymous16> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем профиль исполнительного органа
     * @param body (optional) 
     * @return OK
     */
    contractorsPOST(body: ContractorForm | undefined): Promise<Contractor> {
        let url_ = this.baseUrl + "/contractors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContractorsPOST(_response);
        });
    }

    protected processContractorsPOST(response: Response): Promise<Contractor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contractor.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим черновик заявки по идентификатору
     * @param storedRequestId Целочисленный идентификатор заявки
     * @return OK
     */
    storedRequestsGET(storedRequestId: number): Promise<StoredRequest> {
        let url_ = this.baseUrl + "/stored-requests/{storedRequestId}";
        if (storedRequestId === undefined || storedRequestId === null)
            throw new Error("The parameter 'storedRequestId' must be defined.");
        url_ = url_.replace("{storedRequestId}", encodeURIComponent("" + storedRequestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoredRequestsGET(_response);
        });
    }

    protected processStoredRequestsGET(response: Response): Promise<StoredRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoredRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u0430 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем черновик заявки по идентификатору
     * @param storedRequestId Целочисленный идентификатор черновика заявки
     * @param body (optional) 
     * @return OK
     */
    storedRequestsPUT(storedRequestId: number, body: StoredRequestForm | undefined): Promise<StoredRequest> {
        let url_ = this.baseUrl + "/stored-requests/{storedRequestId}";
        if (storedRequestId === undefined || storedRequestId === null)
            throw new Error("The parameter 'storedRequestId' must be defined.");
        url_ = url_.replace("{storedRequestId}", encodeURIComponent("" + storedRequestId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoredRequestsPUT(_response);
        });
    }

    protected processStoredRequestsPUT(response: Response): Promise<StoredRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoredRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u0430 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем черновик заявки по идентификатору
     * @param storedRequestId Parameter description in CommonMark or HTML.
     * @return OK
     */
    storedRequestsDELETE(storedRequestId: number): Promise<StoredRequest> {
        let url_ = this.baseUrl + "/stored-requests/{storedRequestId}";
        if (storedRequestId === undefined || storedRequestId === null)
            throw new Error("The parameter 'storedRequestId' must be defined.");
        url_ = url_.replace("{storedRequestId}", encodeURIComponent("" + storedRequestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoredRequestsDELETE(_response);
        });
    }

    protected processStoredRequestsDELETE(response: Response): Promise<StoredRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoredRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список черновиков заявок
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    storedRequestsGET2(page: number | undefined, size: number | undefined): Promise<Anonymous17> {
        let url_ = this.baseUrl + "/stored-requests?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoredRequestsGET2(_response);
        });
    }

    protected processStoredRequestsGET2(response: Response): Promise<Anonymous17> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем черновик заявки.
     * @param body (optional) 
     * @return OK
     */
    storedRequestsPOST(body: StoredRequestForm | undefined): Promise<StoredRequest> {
        let url_ = this.baseUrl + "/stored-requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoredRequestsPOST(_response);
        });
    }

    protected processStoredRequestsPOST(response: Response): Promise<StoredRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoredRequest.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим роль по идентификатору
     * @param roleId Целочисленный идентификатор заявки
     * @return OK
     */
    rolesGET(roleId: number): Promise<Role> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesGET(_response);
        });
    }

    protected processRolesGET(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u0430 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем роль по идентификатору
     * @param roleId Целочисленный идентификатор роли
     * @param body (optional) 
     * @return OK
     */
    rolesPUT2(roleId: number, body: RoleForm | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesPUT2(_response);
        });
    }

    protected processRolesPUT2(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u0430 \u0437\u0430\u044f\u0432\u043a\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем роль по идентификатору
     * @param roleId Parameter description in CommonMark or HTML.
     * @return OK
     */
    rolesDELETE(roleId: number): Promise<Role> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesDELETE(_response);
        });
    }

    protected processRolesDELETE(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список всех ролей
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    rolesGET2(page: number | undefined, size: number | undefined): Promise<Anonymous18> {
        let url_ = this.baseUrl + "/roles?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesGET2(_response);
        });
    }

    protected processRolesGET2(response: Response): Promise<Anonymous18> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем новую роль
     * @param body (optional) 
     * @return OK
     */
    rolesPOST(body: RoleForm | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesPOST(_response);
        });
    }

    protected processRolesPOST(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим рассылку по идентификатору
     * @param mailingId Целочисленный идентификатор записи
     * @return OK
     */
    mailingGET(mailingId: number): Promise<MailingQuery> {
        let url_ = this.baseUrl + "/mailing/{mailingId}";
        if (mailingId === undefined || mailingId === null)
            throw new Error("The parameter 'mailingId' must be defined.");
        url_ = url_.replace("{mailingId}", encodeURIComponent("" + mailingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailingGET(_response);
        });
    }

    protected processMailingGET(response: Response): Promise<MailingQuery> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailingQuery.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем черновик заявки по идентификатору
     * @param mailingId Целочисленный идентификатор
     * @param body (optional) 
     * @return OK
     */
    mailingPUT(mailingId: number, body: MailingQueryForm | undefined): Promise<MailingQuery> {
        let url_ = this.baseUrl + "/mailing/{mailingId}";
        if (mailingId === undefined || mailingId === null)
            throw new Error("The parameter 'mailingId' must be defined.");
        url_ = url_.replace("{mailingId}", encodeURIComponent("" + mailingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailingPUT(_response);
        });
    }

    protected processMailingPUT(response: Response): Promise<MailingQuery> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailingQuery.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u0430 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * удаляем из рассылки по идентификатору
     * @param mailingId Parameter description in CommonMark or HTML.
     * @return OK
     */
    mailingDELETE(mailingId: number): Promise<MailingQuery> {
        let url_ = this.baseUrl + "/mailing/{mailingId}";
        if (mailingId === undefined || mailingId === null)
            throw new Error("The parameter 'mailingId' must be defined.");
        url_ = url_.replace("{mailingId}", encodeURIComponent("" + mailingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailingDELETE(_response);
        });
    }

    protected processMailingDELETE(response: Response): Promise<MailingQuery> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailingQuery.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A user with the specified ID was not found.", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список всех рассылок
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    mailingGET2(page: number | undefined, size: number | undefined): Promise<Anonymous19> {
        let url_ = this.baseUrl + "/mailing?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailingGET2(_response);
        });
    }

    protected processMailingGET2(response: Response): Promise<Anonymous19> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем рассылку
     * @param body (optional) 
     * @return OK
     */
    mailingPOST2(body: MailingQueryForm | undefined): Promise<MailingQuery> {
        let url_ = this.baseUrl + "/mailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailingPOST2(_response);
        });
    }

    protected processMailingPOST2(response: Response): Promise<MailingQuery> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailingQuery.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * запуск рассылок в CRON
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    handler(page: number | undefined, size: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/mailing/handler?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandler(_response);
        });
    }

    protected processHandler(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим задачу по по идентификатору
     * @param taskId Целочисленный идентификатор записи
     * @return OK
     */
    tasksGET2(taskId: number): Promise<ContractorTask> {
        let url_ = this.baseUrl + "/tasks/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksGET2(_response);
        });
    }

    protected processTasksGET2(response: Response): Promise<ContractorTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем заявку по идентификатору
     * @param taskId Целочисленный идентификатор
     * @param body (optional) 
     * @return OK
     */
    tasksPUT(taskId: number, body: ContractorTaskForm | undefined): Promise<ContractorTask> {
        let url_ = this.baseUrl + "/tasks/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksPUT(_response);
        });
    }

    protected processTasksPUT(response: Response): Promise<ContractorTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u0430 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * удаляем задачу по идентификатору
     * @param taskId Parameter description in CommonMark or HTML.
     * @return OK
     */
    tasksDELETE(taskId: number): Promise<ContractorTask> {
        let url_ = this.baseUrl + "/tasks/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksDELETE(_response);
        });
    }

    protected processTasksDELETE(response: Response): Promise<ContractorTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The specified user ID is invalid (not a number).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("\u0437\u0430\u0434\u0430\u0447\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список всех задач
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    tasksGET3(page: number | undefined, size: number | undefined): Promise<Anonymous20> {
        let url_ = this.baseUrl + "/tasks?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksGET3(_response);
        });
    }

    protected processTasksGET3(response: Response): Promise<Anonymous20> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем новую задачу для исполнительного \ контролирующего органа
     * @param body (optional) 
     * @return OK
     */
    tasksPOST(body: ContractorTaskForm | undefined): Promise<ContractorTask> {
        let url_ = this.baseUrl + "/tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksPOST(_response);
        });
    }

    protected processTasksPOST(response: Response): Promise<ContractorTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorTask.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим историю по идентификатору
     * @param storyId Целочисленный идентификатор истории
     * @return OK
     */
    storiesGET(storyId: number): Promise<Story> {
        let url_ = this.baseUrl + "/stories/{storyId}";
        if (storyId === undefined || storyId === null)
            throw new Error("The parameter 'storyId' must be defined.");
        url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoriesGET(_response);
        });
    }

    protected processStoriesGET(response: Response): Promise<Story> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Story.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0438\u0441\u0442\u043e\u0440\u0438\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0418\u0441\u0442\u043e\u0440\u0438\u044f \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем историю по идентификатору
     * @param storyId Целочисленный идентификатор истории
     * @param body (optional) 
     * @return OK
     */
    storiesPUT(storyId: number, body: StoryForm | undefined): Promise<Story> {
        let url_ = this.baseUrl + "/stories/{storyId}";
        if (storyId === undefined || storyId === null)
            throw new Error("The parameter 'storyId' must be defined.");
        url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoriesPUT(_response);
        });
    }

    protected processStoriesPUT(response: Response): Promise<Story> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Story.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0438\u0441\u0442\u043e\u0440\u0438\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0418\u0441\u0442\u043e\u0440\u0438\u044f \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем историю по идентификатору
     * @param storyId Parameter description in CommonMark or HTML.
     * @return OK
     */
    storiesDELETE(storyId: number): Promise<Role> {
        let url_ = this.baseUrl + "/stories/{storyId}";
        if (storyId === undefined || storyId === null)
            throw new Error("The parameter 'storyId' must be defined.");
        url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoriesDELETE(_response);
        });
    }

    protected processStoriesDELETE(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("\u0418\u0441\u0442\u043e\u0440\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u043c \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u043e\u043c \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Устанавливает просмотр истории для текущего пользователя
     * @param storyId Целочисленный идентификатор истории
     * @return OK
     */
    watch2(storyId: number): Promise<void> {
        let url_ = this.baseUrl + "/stories/{storyId}/watch";
        if (storyId === undefined || storyId === null)
            throw new Error("The parameter 'storyId' must be defined.");
        url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWatch2(_response);
        });
    }

    protected processWatch2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0438\u0441\u0442\u043e\u0440\u0438\u0438 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0418\u0441\u0442\u043e\u0440\u0438\u044f \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Список всех историй
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    storiesGET2(page: number | undefined, size: number | undefined): Promise<Anonymous21> {
        let url_ = this.baseUrl + "/stories?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoriesGET2(_response);
        });
    }

    protected processStoriesGET2(response: Response): Promise<Anonymous21> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем новую историю
     * @param body (optional) 
     * @return OK
     */
    storiesPOST(body: StoryForm | undefined): Promise<Story> {
        let url_ = this.baseUrl + "/stories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoriesPOST(_response);
        });
    }

    protected processStoriesPOST(response: Response): Promise<Story> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Story.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Находим регион по идентификатору
     * @param regionId Целочисленный идентификатор истории
     * @return OK
     */
    regionsGET(regionId: number): Promise<Region> {
        let url_ = this.baseUrl + "/regions/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegionsGET(_response);
        });
    }

    protected processRegionsGET(response: Response): Promise<Region> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0440\u0435\u0433\u0438\u043e\u043d\u0430 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0420\u0435\u0433\u0438\u043e\u043d \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Обновляем регион по идентификатору
     * @param regionId Целочисленный идентификатор регион
     * @param body (optional) 
     * @return OK
     */
    regionsPUT(regionId: number, body: RegionForm | undefined): Promise<Region> {
        let url_ = this.baseUrl + "/regions/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegionsPUT(_response);
        });
    }

    protected processRegionsPUT(response: Response): Promise<Region> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0440\u0435\u0433\u0438\u043e\u043d\u0430 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("\u0420\u0435\u0433\u0438\u043e\u043d \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Удаляем регион по идентификатору
     * @return OK
     */
    regionsDELETE(regionId: number): Promise<Region> {
        let url_ = this.baseUrl + "/regions/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegionsDELETE(_response);
        });
    }

    protected processRegionsDELETE(response: Response): Promise<Region> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("\u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e\u043c", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("\u0420\u0435\u0433\u0438\u043e\u043d \u0441 \u0434\u0430\u043d\u043d\u044b\u043c \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u043e\u043c \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers);
            });
        } else {
            return response.text().then((_responseText) => {
            return throwException("Unexpected error", status, _responseText, _headers);
            });
        }
    }

    /**
     * Список всех регионов
     * @param page (optional) идентификатор страницы
     * @param size (optional) размер выдачи на странице
     * @return OK
     */
    regionsGET2(page: number | undefined, size: number | undefined): Promise<Anonymous22> {
        let url_ = this.baseUrl + "/regions?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegionsGET2(_response);
        });
    }

    protected processRegionsGET2(response: Response): Promise<Anonymous22> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Создаем новуый регион
     * @param body (optional) 
     * @return OK
     */
    regionsPOST(body: RegionForm | undefined): Promise<Region> {
        let url_ = this.baseUrl + "/regions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegionsPOST(_response);
        });
    }

    protected processRegionsPOST(response: Response): Promise<Region> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("Unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class ErrorDto implements IErrorDto {
    title!: string;
    message!: string;
    code!: number;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.title = "Error";
            this.message = "Error";
            this.code = 404;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : "Error";
            this.message = _data["message"] !== undefined ? _data["message"] : "Error";
            this.code = _data["code"] !== undefined ? _data["code"] : 404;
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["message"] = this.message;
        data["code"] = this.code;
        return data;
    }
}

export interface IErrorDto {
    title: string;
    message: string;
    code: number;
}

export class User implements IUser {
    id?: number;
    username!: string;
    password!: string;
    profile?: Profile;
    roles?: Role[];
    approve_sms_code?: string;
    approve_email_code?: string;
    sms_approved_at?: string;
    email_approved_at?: string;
    blocked_at?: string;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.profile = _data["profile"] ? Profile.fromJS(_data["profile"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.approve_sms_code = _data["approve_sms_code"];
            this.approve_email_code = _data["approve_email_code"];
            this.sms_approved_at = _data["sms_approved_at"];
            this.email_approved_at = _data["email_approved_at"];
            this.blocked_at = _data["blocked_at"];
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["password"] = this.password;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["approve_sms_code"] = this.approve_sms_code;
        data["approve_email_code"] = this.approve_email_code;
        data["sms_approved_at"] = this.sms_approved_at;
        data["email_approved_at"] = this.email_approved_at;
        data["blocked_at"] = this.blocked_at;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IUser {
    id?: number;
    username: string;
    password: string;
    profile?: Profile;
    roles?: Role[];
    approve_sms_code?: string;
    approve_email_code?: string;
    sms_approved_at?: string;
    email_approved_at?: string;
    blocked_at?: string;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class UserForm implements IUserForm {
    username!: string;
    password?: string;

    constructor(data?: IUserForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserForm {
        data = typeof data === 'object' ? data : {};
        let result = new UserForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IUserForm {
    username: string;
    password?: string;
}

export class Role implements IRole {
    id?: number;
    /** Роли пользователя:
  * `GUEST` - гость (не используется)
  * `USER` - польователь системы
  * `ADMINISTRATOR` - администратор системы
  * `CONTRACTOR` - исполнительный или контролирующий орган
  * `CONTRACTOR_EXECUTIVE` - исполнительный орган
  * `CONTRACTOR_SUPERVISING` - контролирующий орган
  * `TECHNICAL` - технический пользователь системы
 */
    title!: RoleTitle;
    /** мнемоническое имя роли */
    slug!: string;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.slug = "guest";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.slug = _data["slug"] !== undefined ? _data["slug"] : "guest";
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IRole {
    id?: number;
    /** Роли пользователя:
  * `GUEST` - гость (не используется)
  * `USER` - польователь системы
  * `ADMINISTRATOR` - администратор системы
  * `CONTRACTOR` - исполнительный или контролирующий орган
  * `CONTRACTOR_EXECUTIVE` - исполнительный орган
  * `CONTRACTOR_SUPERVISING` - контролирующий орган
  * `TECHNICAL` - технический пользователь системы
 */
    title: RoleTitle;
    /** мнемоническое имя роли */
    slug: string;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class RoleForm implements IRoleForm {
    /** Роли пользователя:
  * `GUEST` - гость (не используется)
  * `USER` - польователь системы
  * `ADMINISTRATOR` - администратор системы
  * `CONTRACTOR` - исполнительный или контролирующий орган
  * `CONTRACTOR_EXECUTIVE` - исполнительный орган
  * `CONTRACTOR_SUPERVISING` - контролирующий орган
  * `TECHNICAL` - технический пользователь системы
 */
    title!: RoleFormTitle;
    /** мнемоническое имя роли */
    slug!: string;

    constructor(data?: IRoleForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.slug = "guest";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.slug = _data["slug"] !== undefined ? _data["slug"] : "guest";
        }
    }

    static fromJS(data: any): RoleForm {
        data = typeof data === 'object' ? data : {};
        let result = new RoleForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IRoleForm {
    /** Роли пользователя:
  * `GUEST` - гость (не используется)
  * `USER` - польователь системы
  * `ADMINISTRATOR` - администратор системы
  * `CONTRACTOR` - исполнительный или контролирующий орган
  * `CONTRACTOR_EXECUTIVE` - исполнительный орган
  * `CONTRACTOR_SUPERVISING` - контролирующий орган
  * `TECHNICAL` - технический пользователь системы
 */
    title: RoleFormTitle;
    /** мнемоническое имя роли */
    slug: string;
}

export class Profile implements IProfile {
    id?: number;
    user_id!: number;
    full_name?: string;
    location?: string;
    phone!: string;
    /** персональный рейтинг пользователя */
    rating?: number;
    email!: string;
    requests?: Request[];
    stored_requests?: StoredRequest[];
    is_notification_email?: boolean;
    is_notification_sms?: boolean;
    is_anonymous_requests?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_notification_email = false;
            this.is_notification_sms = false;
            this.is_anonymous_requests = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_id = _data["user_id"];
            this.full_name = _data["full_name"];
            this.location = _data["location"];
            this.phone = _data["phone"];
            this.rating = _data["rating"];
            this.email = _data["email"];
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests!.push(Request.fromJS(item));
            }
            if (Array.isArray(_data["stored_requests"])) {
                this.stored_requests = [] as any;
                for (let item of _data["stored_requests"])
                    this.stored_requests!.push(StoredRequest.fromJS(item));
            }
            this.is_notification_email = _data["is_notification_email"] !== undefined ? _data["is_notification_email"] : false;
            this.is_notification_sms = _data["is_notification_sms"] !== undefined ? _data["is_notification_sms"] : false;
            this.is_anonymous_requests = _data["is_anonymous_requests"] !== undefined ? _data["is_anonymous_requests"] : false;
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_id"] = this.user_id;
        data["full_name"] = this.full_name;
        data["location"] = this.location;
        data["phone"] = this.phone;
        data["rating"] = this.rating;
        data["email"] = this.email;
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        if (Array.isArray(this.stored_requests)) {
            data["stored_requests"] = [];
            for (let item of this.stored_requests)
                data["stored_requests"].push(item.toJSON());
        }
        data["is_notification_email"] = this.is_notification_email;
        data["is_notification_sms"] = this.is_notification_sms;
        data["is_anonymous_requests"] = this.is_anonymous_requests;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IProfile {
    id?: number;
    user_id: number;
    full_name?: string;
    location?: string;
    phone: string;
    /** персональный рейтинг пользователя */
    rating?: number;
    email: string;
    requests?: Request[];
    stored_requests?: StoredRequest[];
    is_notification_email?: boolean;
    is_notification_sms?: boolean;
    is_anonymous_requests?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class ProfileForm implements IProfileForm {
    user_id!: number;
    full_name!: string;
    location?: string;
    phone?: string;
    email!: string;
    is_notification_email?: boolean;
    is_notification_sms?: boolean;
    is_anonymous_requests?: boolean;

    constructor(data?: IProfileForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_notification_email = false;
            this.is_notification_sms = false;
            this.is_anonymous_requests = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.full_name = _data["full_name"];
            this.location = _data["location"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.is_notification_email = _data["is_notification_email"] !== undefined ? _data["is_notification_email"] : false;
            this.is_notification_sms = _data["is_notification_sms"] !== undefined ? _data["is_notification_sms"] : false;
            this.is_anonymous_requests = _data["is_anonymous_requests"] !== undefined ? _data["is_anonymous_requests"] : false;
        }
    }

    static fromJS(data: any): ProfileForm {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["full_name"] = this.full_name;
        data["location"] = this.location;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["is_notification_email"] = this.is_notification_email;
        data["is_notification_sms"] = this.is_notification_sms;
        data["is_anonymous_requests"] = this.is_anonymous_requests;
        return data;
    }
}

export interface IProfileForm {
    user_id: number;
    full_name: string;
    location?: string;
    phone?: string;
    email: string;
    is_notification_email?: boolean;
    is_notification_sms?: boolean;
    is_anonymous_requests?: boolean;
}

export class Request implements IRequest {
    id?: number;
    /** идентификатор более ранней заявки по схожей проблеме */
    parent_request_id?: number;
    description?: string;
    /** Источник заявки:
  * `LANDING` - с рекламной страницы
  * `VK` - с вк бота
  * `OPERATOR` - добавлено оператором из административной панели
  * `EXCEL` - массовое добавление из эксель файла
  * `TELEGRAM` - с телеграм бота
  * `ANDROID` - с андройд приложения
  * `IOS` - а ios приложения
  * `OTHER` - с других источников
 */
    source?: RequestSource;
    problem_categories?: ProblemCategory[];
    location?: string;
    latitude?: number;
    longitude?: number;
    /** фиксированный рейтинг заявки, указывается администратором для принудительного повышения */
    base_rating?: number;
    /** суммарный рейтинг заявки и всех смежных с ней заявок */
    rating?: number;
    /** число просмотров заявки (расчетный параметр) */
    watch_count?: number;
    /** Тип заявки:
 * `IN PROCESSING` - новая заявка
 * `IN CONSIDERATION` - заявка на рассмотрении
 * `IN EXECUTION` - заявка выполняется
 * `IN EXECUTION CHECK` - проверка выполнения заявки
 * `COMPLETED` - выполненная заявка
 * `ARCHIVED` - заявка находится в архиве
 */
    status?: RequestStatus;
    attachments?: MediaContent[];
    /** сохранение данных профиля на момент формирования заявки */
    stored_profile_data?: Stored_profile_data;
    /** дата начала рассмотрения заявки */
    request_consideration_at?: string;
    /** дата начала выполнения работ по заявке */
    begin_request_execution_at?: string;
    /** дата завершения выполнения работ по заявке */
    complete_request_execution_at?: string;
    /** дата финальной проверки выполнения */
    request_status_checked_at?: string;
    is_moderated?: boolean;
    moderator_id?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.base_rating = 0;
            this.status = RequestStatus.IN_PROCESSING;
            this.is_moderated = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parent_request_id = _data["parent_request_id"];
            this.description = _data["description"];
            this.source = _data["source"];
            if (Array.isArray(_data["problem_categories"])) {
                this.problem_categories = [] as any;
                for (let item of _data["problem_categories"])
                    this.problem_categories!.push(ProblemCategory.fromJS(item));
            }
            this.location = _data["location"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.base_rating = _data["base_rating"] !== undefined ? _data["base_rating"] : 0;
            this.rating = _data["rating"];
            this.watch_count = _data["watch_count"];
            this.status = _data["status"] !== undefined ? _data["status"] : RequestStatus.IN_PROCESSING;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
            this.stored_profile_data = _data["stored_profile_data"] ? Stored_profile_data.fromJS(_data["stored_profile_data"]) : <any>undefined;
            this.request_consideration_at = _data["request_consideration_at"];
            this.begin_request_execution_at = _data["begin_request_execution_at"];
            this.complete_request_execution_at = _data["complete_request_execution_at"];
            this.request_status_checked_at = _data["request_status_checked_at"];
            this.is_moderated = _data["is_moderated"] !== undefined ? _data["is_moderated"] : true;
            this.moderator_id = _data["moderator_id"];
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parent_request_id"] = this.parent_request_id;
        data["description"] = this.description;
        data["source"] = this.source;
        if (Array.isArray(this.problem_categories)) {
            data["problem_categories"] = [];
            for (let item of this.problem_categories)
                data["problem_categories"].push(item.toJSON());
        }
        data["location"] = this.location;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["base_rating"] = this.base_rating;
        data["rating"] = this.rating;
        data["watch_count"] = this.watch_count;
        data["status"] = this.status;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["stored_profile_data"] = this.stored_profile_data ? this.stored_profile_data.toJSON() : <any>undefined;
        data["request_consideration_at"] = this.request_consideration_at;
        data["begin_request_execution_at"] = this.begin_request_execution_at;
        data["complete_request_execution_at"] = this.complete_request_execution_at;
        data["request_status_checked_at"] = this.request_status_checked_at;
        data["is_moderated"] = this.is_moderated;
        data["moderator_id"] = this.moderator_id;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IRequest {
    id?: number;
    /** идентификатор более ранней заявки по схожей проблеме */
    parent_request_id?: number;
    description?: string;
    /** Источник заявки:
  * `LANDING` - с рекламной страницы
  * `VK` - с вк бота
  * `OPERATOR` - добавлено оператором из административной панели
  * `EXCEL` - массовое добавление из эксель файла
  * `TELEGRAM` - с телеграм бота
  * `ANDROID` - с андройд приложения
  * `IOS` - а ios приложения
  * `OTHER` - с других источников
 */
    source?: RequestSource;
    problem_categories?: ProblemCategory[];
    location?: string;
    latitude?: number;
    longitude?: number;
    /** фиксированный рейтинг заявки, указывается администратором для принудительного повышения */
    base_rating?: number;
    /** суммарный рейтинг заявки и всех смежных с ней заявок */
    rating?: number;
    /** число просмотров заявки (расчетный параметр) */
    watch_count?: number;
    /** Тип заявки:
 * `IN PROCESSING` - новая заявка
 * `IN CONSIDERATION` - заявка на рассмотрении
 * `IN EXECUTION` - заявка выполняется
 * `IN EXECUTION CHECK` - проверка выполнения заявки
 * `COMPLETED` - выполненная заявка
 * `ARCHIVED` - заявка находится в архиве
 */
    status?: RequestStatus;
    attachments?: MediaContent[];
    /** сохранение данных профиля на момент формирования заявки */
    stored_profile_data?: Stored_profile_data;
    /** дата начала рассмотрения заявки */
    request_consideration_at?: string;
    /** дата начала выполнения работ по заявке */
    begin_request_execution_at?: string;
    /** дата завершения выполнения работ по заявке */
    complete_request_execution_at?: string;
    /** дата финальной проверки выполнения */
    request_status_checked_at?: string;
    is_moderated?: boolean;
    moderator_id?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class RequestForm implements IRequestForm {
    /** идентификатор более ранней заявки по схожей проблеме */
    parent_request_id?: number;
    description!: string;
    /** Источник заявки:
  * `LANDING` - с рекламной страницы
  * `VK` - с вк бота
  * `OPERATOR` - добавлено оператором из административной панели
  * `EXCEL` - массовое добавление из эксель файла
  * `TELEGRAM` - с телеграм бота
  * `ANDROID` - с андройд приложения
  * `IOS` - а ios приложения
  * `OTHER` - с других источников
 */
    source!: RequestFormSource;
    problem_categories!: number[];
    location?: string;
    latitude!: number;
    longitude!: number;
    /** фиксированный рейтинг заявки, указывается администратором для принудительного повышения */
    base_rating?: number;
    /** Тип заявки:
 * `IN PROCESSING` - новая заявка
 * `IN CONSIDERATION` - заявка на рассмотрении
 * `IN EXECUTION` - заявка выполняется
 * `IN EXECUTION CHECK` - проверка выполнения заявки
 * `COMPLETED` - выполненная заявка
 * `ARCHIVED` - заявка находится в архиве
 */
    status?: RequestFormStatus;
    attachments?: MediaContent[];
    /** дата начала рассмотрения заявки */
    request_consideration_at?: string;
    /** дата начала выполнения работ по заявке */
    begin_request_execution_at?: string;
    /** дата завершения выполнения работ по заявке */
    complete_request_execution_at?: string;
    /** дата финальной проверки выполнения */
    request_status_checked_at?: string;
    is_moderated?: boolean;
    moderator_id?: number;
    filenames?: string[];

    constructor(data?: IRequestForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.problem_categories = [];
            this.base_rating = 0;
            this.status = RequestFormStatus.IN_PROCESSING;
            this.is_moderated = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent_request_id = _data["parent_request_id"];
            this.description = _data["description"];
            this.source = _data["source"];
            if (Array.isArray(_data["problem_categories"])) {
                this.problem_categories = [] as any;
                for (let item of _data["problem_categories"])
                    this.problem_categories!.push(item);
            }
            this.location = _data["location"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.base_rating = _data["base_rating"] !== undefined ? _data["base_rating"] : 0;
            this.status = _data["status"] !== undefined ? _data["status"] : RequestFormStatus.IN_PROCESSING;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
            this.request_consideration_at = _data["request_consideration_at"];
            this.begin_request_execution_at = _data["begin_request_execution_at"];
            this.complete_request_execution_at = _data["complete_request_execution_at"];
            this.request_status_checked_at = _data["request_status_checked_at"];
            this.is_moderated = _data["is_moderated"] !== undefined ? _data["is_moderated"] : true;
            this.moderator_id = _data["moderator_id"];
            if (Array.isArray(_data["filenames"])) {
                this.filenames = [] as any;
                for (let item of _data["filenames"])
                    this.filenames!.push(item);
            }
        }
    }

    static fromJS(data: any): RequestForm {
        data = typeof data === 'object' ? data : {};
        let result = new RequestForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent_request_id"] = this.parent_request_id;
        data["description"] = this.description;
        data["source"] = this.source;
        if (Array.isArray(this.problem_categories)) {
            data["problem_categories"] = [];
            for (let item of this.problem_categories)
                data["problem_categories"].push(item);
        }
        data["location"] = this.location;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["base_rating"] = this.base_rating;
        data["status"] = this.status;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["request_consideration_at"] = this.request_consideration_at;
        data["begin_request_execution_at"] = this.begin_request_execution_at;
        data["complete_request_execution_at"] = this.complete_request_execution_at;
        data["request_status_checked_at"] = this.request_status_checked_at;
        data["is_moderated"] = this.is_moderated;
        data["moderator_id"] = this.moderator_id;
        if (Array.isArray(this.filenames)) {
            data["filenames"] = [];
            for (let item of this.filenames)
                data["filenames"].push(item);
        }
        return data;
    }
}

export interface IRequestForm {
    /** идентификатор более ранней заявки по схожей проблеме */
    parent_request_id?: number;
    description: string;
    /** Источник заявки:
  * `LANDING` - с рекламной страницы
  * `VK` - с вк бота
  * `OPERATOR` - добавлено оператором из административной панели
  * `EXCEL` - массовое добавление из эксель файла
  * `TELEGRAM` - с телеграм бота
  * `ANDROID` - с андройд приложения
  * `IOS` - а ios приложения
  * `OTHER` - с других источников
 */
    source: RequestFormSource;
    problem_categories: number[];
    location?: string;
    latitude: number;
    longitude: number;
    /** фиксированный рейтинг заявки, указывается администратором для принудительного повышения */
    base_rating?: number;
    /** Тип заявки:
 * `IN PROCESSING` - новая заявка
 * `IN CONSIDERATION` - заявка на рассмотрении
 * `IN EXECUTION` - заявка выполняется
 * `IN EXECUTION CHECK` - проверка выполнения заявки
 * `COMPLETED` - выполненная заявка
 * `ARCHIVED` - заявка находится в архиве
 */
    status?: RequestFormStatus;
    attachments?: MediaContent[];
    /** дата начала рассмотрения заявки */
    request_consideration_at?: string;
    /** дата начала выполнения работ по заявке */
    begin_request_execution_at?: string;
    /** дата завершения выполнения работ по заявке */
    complete_request_execution_at?: string;
    /** дата финальной проверки выполнения */
    request_status_checked_at?: string;
    is_moderated?: boolean;
    moderator_id?: number;
    filenames?: string[];
}

export class StoredRequest implements IStoredRequest {
    id?: number;
    /** идентификатор пользователя, который сохраняет заявку */
    user_id?: number;
    description?: string;
    problem_categories?: ProblemCategory[];
    latitude?: number;
    longitude?: number;
    attachments?: MediaContent[];
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IStoredRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_id = _data["user_id"];
            this.description = _data["description"];
            if (Array.isArray(_data["problem_categories"])) {
                this.problem_categories = [] as any;
                for (let item of _data["problem_categories"])
                    this.problem_categories!.push(ProblemCategory.fromJS(item));
            }
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): StoredRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StoredRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_id"] = this.user_id;
        data["description"] = this.description;
        if (Array.isArray(this.problem_categories)) {
            data["problem_categories"] = [];
            for (let item of this.problem_categories)
                data["problem_categories"].push(item.toJSON());
        }
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IStoredRequest {
    id?: number;
    /** идентификатор пользователя, который сохраняет заявку */
    user_id?: number;
    description?: string;
    problem_categories?: ProblemCategory[];
    latitude?: number;
    longitude?: number;
    attachments?: MediaContent[];
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class StoredRequestForm implements IStoredRequestForm {
    /** идентификатор пользователя, который сохраняет заявку */
    user_id?: number;
    description!: string;
    problem_categories!: ProblemCategory[];
    latitude!: number;
    longitude!: number;
    attachments?: MediaContent[];

    constructor(data?: IStoredRequestForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.problem_categories = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.description = _data["description"];
            if (Array.isArray(_data["problem_categories"])) {
                this.problem_categories = [] as any;
                for (let item of _data["problem_categories"])
                    this.problem_categories!.push(ProblemCategory.fromJS(item));
            }
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoredRequestForm {
        data = typeof data === 'object' ? data : {};
        let result = new StoredRequestForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["description"] = this.description;
        if (Array.isArray(this.problem_categories)) {
            data["problem_categories"] = [];
            for (let item of this.problem_categories)
                data["problem_categories"].push(item.toJSON());
        }
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStoredRequestForm {
    /** идентификатор пользователя, который сохраняет заявку */
    user_id?: number;
    description: string;
    problem_categories: ProblemCategory[];
    latitude: number;
    longitude: number;
    attachments?: MediaContent[];
}

export class ProblemCategory implements IProblemCategory {
    id?: number;
    title?: string;
    mnemonic_name?: string;
    hash_tag?: string;
    icon?: string;
    /** Приоритетный рейтинг категории */
    rating?: number;
    /** Доступность раздела */
    is_active?: boolean;
    /** Видимость раздела в общей выдаче */
    is_visible?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IProblemCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.mnemonic_name = _data["mnemonic_name"];
            this.hash_tag = _data["hash_tag"];
            this.icon = _data["icon"];
            this.rating = _data["rating"];
            this.is_active = _data["is_active"];
            this.is_visible = _data["is_visible"];
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): ProblemCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["mnemonic_name"] = this.mnemonic_name;
        data["hash_tag"] = this.hash_tag;
        data["icon"] = this.icon;
        data["rating"] = this.rating;
        data["is_active"] = this.is_active;
        data["is_visible"] = this.is_visible;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IProblemCategory {
    id?: number;
    title?: string;
    mnemonic_name?: string;
    hash_tag?: string;
    icon?: string;
    /** Приоритетный рейтинг категории */
    rating?: number;
    /** Доступность раздела */
    is_active?: boolean;
    /** Видимость раздела в общей выдаче */
    is_visible?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class ProblemCategoryForm implements IProblemCategoryForm {
    title!: string;
    mnemonic_name!: string;
    hash_tag!: string;
    icon!: string;
    /** Приоритетный рейтинг категории */
    rating?: number;
    /** Доступность раздела */
    is_active?: boolean;
    /** Видимость раздела в общей выдаче */
    is_visible?: boolean;

    constructor(data?: IProblemCategoryForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.mnemonic_name = _data["mnemonic_name"];
            this.hash_tag = _data["hash_tag"];
            this.icon = _data["icon"];
            this.rating = _data["rating"];
            this.is_active = _data["is_active"];
            this.is_visible = _data["is_visible"];
        }
    }

    static fromJS(data: any): ProblemCategoryForm {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemCategoryForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["mnemonic_name"] = this.mnemonic_name;
        data["hash_tag"] = this.hash_tag;
        data["icon"] = this.icon;
        data["rating"] = this.rating;
        data["is_active"] = this.is_active;
        data["is_visible"] = this.is_visible;
        return data;
    }
}

export interface IProblemCategoryForm {
    title: string;
    mnemonic_name: string;
    hash_tag: string;
    icon: string;
    /** Приоритетный рейтинг категории */
    rating?: number;
    /** Доступность раздела */
    is_active?: boolean;
    /** Видимость раздела в общей выдаче */
    is_visible?: boolean;
}

export class MediaContent implements IMediaContent {
    /** Тип медиа данных:
 * `IMAGE` - изображение
 * `VIDEO` - видео
 */
    type!: MediaContentType;
    url!: string;

    constructor(data?: IMediaContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.type = MediaContentType.IMAGE;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : MediaContentType.IMAGE;
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): MediaContent {
        data = typeof data === 'object' ? data : {};
        let result = new MediaContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }
}

export interface IMediaContent {
    /** Тип медиа данных:
 * `IMAGE` - изображение
 * `VIDEO` - видео
 */
    type: MediaContentType;
    url: string;
}

export class PaginateObject implements IPaginateObject {
    links?: Links;
    current_page?: number;
    from?: number;
    last_page?: number;
    path?: string;
    per_page?: number;
    to?: number;
    total?: number;

    constructor(data?: IPaginateObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.links = _data["links"] ? Links.fromJS(_data["links"]) : <any>undefined;
            this.current_page = _data["current_page"];
            this.from = _data["from"];
            this.last_page = _data["last_page"];
            this.path = _data["path"];
            this.per_page = _data["per_page"];
            this.to = _data["to"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PaginateObject {
        data = typeof data === 'object' ? data : {};
        let result = new PaginateObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["links"] = this.links ? this.links.toJSON() : <any>undefined;
        data["current_page"] = this.current_page;
        data["from"] = this.from;
        data["last_page"] = this.last_page;
        data["path"] = this.path;
        data["per_page"] = this.per_page;
        data["to"] = this.to;
        data["total"] = this.total;
        return data;
    }
}

export interface IPaginateObject {
    links?: Links;
    current_page?: number;
    from?: number;
    last_page?: number;
    path?: string;
    per_page?: number;
    to?: number;
    total?: number;
}

export class Contractor implements IContractor {
    id?: number;
    /** Мнемоническое имя */
    mnemonic_name?: string;
    /** Название исполнительного органа */
    title?: string;
    /** Описание исполнительного органа */
    description?: string;
    /** Ответственное лицо от органа исполнения  проверки */
    responsible_person?: string;
    /** Изображение (аватар исполнительного органа) */
    image?: string;
    hash_tag?: string;
    contact_phone?: string;
    contact_email?: string;
    /** электронная почта отвественного министерства */
    pre_controller_email?: string;
    /** идентификатор телеграм канала исполнительного органа */
    telegram_chat_id?: string;
    /** Ссылка на веб-ресурс службы */
    public_website?: string;
    /** дополнительная информация о контролирующем \ исполнительном органе */
    more_info?: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type?: ContractorType;
    schedule?: Schedule[];
    /** категории проблем, за которые ответственный орган */
    problem_categories?: ProblemCategory[];
    /** Статус видимости организации в общем списке */
    is_active?: boolean;
    /** Генерировать дневные отчеты */
    generate_daily_report?: boolean;
    /** информировать по электронной почте */
    need_inform_by_email?: boolean;
    /** информировать по sms */
    need_inform_by_sms?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IContractor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.type = ContractorType.EXECUTIVE;
            this.is_active = false;
            this.generate_daily_report = false;
            this.need_inform_by_email = false;
            this.need_inform_by_sms = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mnemonic_name = _data["mnemonic_name"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.responsible_person = _data["responsible_person"];
            this.image = _data["image"];
            this.hash_tag = _data["hash_tag"];
            this.contact_phone = _data["contact_phone"];
            this.contact_email = _data["contact_email"];
            this.pre_controller_email = _data["pre_controller_email"];
            this.telegram_chat_id = _data["telegram_chat_id"];
            this.public_website = _data["public_website"];
            this.more_info = _data["more_info"];
            this.type = _data["type"] !== undefined ? _data["type"] : ContractorType.EXECUTIVE;
            if (Array.isArray(_data["schedule"])) {
                this.schedule = [] as any;
                for (let item of _data["schedule"])
                    this.schedule!.push(Schedule.fromJS(item));
            }
            if (Array.isArray(_data["problem_categories"])) {
                this.problem_categories = [] as any;
                for (let item of _data["problem_categories"])
                    this.problem_categories!.push(ProblemCategory.fromJS(item));
            }
            this.is_active = _data["is_active"] !== undefined ? _data["is_active"] : false;
            this.generate_daily_report = _data["generate_daily_report"] !== undefined ? _data["generate_daily_report"] : false;
            this.need_inform_by_email = _data["need_inform_by_email"] !== undefined ? _data["need_inform_by_email"] : false;
            this.need_inform_by_sms = _data["need_inform_by_sms"] !== undefined ? _data["need_inform_by_sms"] : false;
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Contractor {
        data = typeof data === 'object' ? data : {};
        let result = new Contractor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mnemonic_name"] = this.mnemonic_name;
        data["title"] = this.title;
        data["description"] = this.description;
        data["responsible_person"] = this.responsible_person;
        data["image"] = this.image;
        data["hash_tag"] = this.hash_tag;
        data["contact_phone"] = this.contact_phone;
        data["contact_email"] = this.contact_email;
        data["pre_controller_email"] = this.pre_controller_email;
        data["telegram_chat_id"] = this.telegram_chat_id;
        data["public_website"] = this.public_website;
        data["more_info"] = this.more_info;
        data["type"] = this.type;
        if (Array.isArray(this.schedule)) {
            data["schedule"] = [];
            for (let item of this.schedule)
                data["schedule"].push(item.toJSON());
        }
        if (Array.isArray(this.problem_categories)) {
            data["problem_categories"] = [];
            for (let item of this.problem_categories)
                data["problem_categories"].push(item.toJSON());
        }
        data["is_active"] = this.is_active;
        data["generate_daily_report"] = this.generate_daily_report;
        data["need_inform_by_email"] = this.need_inform_by_email;
        data["need_inform_by_sms"] = this.need_inform_by_sms;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IContractor {
    id?: number;
    /** Мнемоническое имя */
    mnemonic_name?: string;
    /** Название исполнительного органа */
    title?: string;
    /** Описание исполнительного органа */
    description?: string;
    /** Ответственное лицо от органа исполнения  проверки */
    responsible_person?: string;
    /** Изображение (аватар исполнительного органа) */
    image?: string;
    hash_tag?: string;
    contact_phone?: string;
    contact_email?: string;
    /** электронная почта отвественного министерства */
    pre_controller_email?: string;
    /** идентификатор телеграм канала исполнительного органа */
    telegram_chat_id?: string;
    /** Ссылка на веб-ресурс службы */
    public_website?: string;
    /** дополнительная информация о контролирующем \ исполнительном органе */
    more_info?: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type?: ContractorType;
    schedule?: Schedule[];
    /** категории проблем, за которые ответственный орган */
    problem_categories?: ProblemCategory[];
    /** Статус видимости организации в общем списке */
    is_active?: boolean;
    /** Генерировать дневные отчеты */
    generate_daily_report?: boolean;
    /** информировать по электронной почте */
    need_inform_by_email?: boolean;
    /** информировать по sms */
    need_inform_by_sms?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class ContractorForm implements IContractorForm {
    /** Мнемоническое имя */
    mnemonic_name!: string;
    /** Название исполнительного органа */
    title!: string;
    /** Описание исполнительного органа */
    description!: string;
    /** Ответственное лицо от органа исполнения  проверки */
    responsible_person!: string;
    /** Изображение (аватар исполнительного органа) */
    image?: string;
    hash_tag!: string;
    contact_phone!: string;
    contact_email!: string;
    /** электронная почта отвественного министерства */
    pre_controller_email?: string;
    /** идентификатор телеграм канала исполнительного органа */
    telegram_chat_id!: string;
    /** Ссылка на веб-ресурс службы */
    public_website?: string;
    /** дополнительная информация о контролирующем \ исполнительном органе */
    more_info?: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type!: ContractorFormType;
    schedule!: Schedule2[];
    problem_categories!: number[];
    /** Статус видимости организации в общем списке */
    is_active?: boolean;
    /** Генерировать дневные отчеты */
    generate_daily_report?: boolean;
    /** информировать по электронной почте */
    need_inform_by_email?: boolean;
    /** информировать по sms */
    need_inform_by_sms?: boolean;

    constructor(data?: IContractorForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.type = ContractorFormType.EXECUTIVE;
            this.schedule = [];
            this.problem_categories = [];
            this.is_active = false;
            this.generate_daily_report = false;
            this.need_inform_by_email = false;
            this.need_inform_by_sms = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mnemonic_name = _data["mnemonic_name"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.responsible_person = _data["responsible_person"];
            this.image = _data["image"];
            this.hash_tag = _data["hash_tag"];
            this.contact_phone = _data["contact_phone"];
            this.contact_email = _data["contact_email"];
            this.pre_controller_email = _data["pre_controller_email"];
            this.telegram_chat_id = _data["telegram_chat_id"];
            this.public_website = _data["public_website"];
            this.more_info = _data["more_info"];
            this.type = _data["type"] !== undefined ? _data["type"] : ContractorFormType.EXECUTIVE;
            if (Array.isArray(_data["schedule"])) {
                this.schedule = [] as any;
                for (let item of _data["schedule"])
                    this.schedule!.push(Schedule2.fromJS(item));
            }
            if (Array.isArray(_data["problem_categories"])) {
                this.problem_categories = [] as any;
                for (let item of _data["problem_categories"])
                    this.problem_categories!.push(item);
            }
            this.is_active = _data["is_active"] !== undefined ? _data["is_active"] : false;
            this.generate_daily_report = _data["generate_daily_report"] !== undefined ? _data["generate_daily_report"] : false;
            this.need_inform_by_email = _data["need_inform_by_email"] !== undefined ? _data["need_inform_by_email"] : false;
            this.need_inform_by_sms = _data["need_inform_by_sms"] !== undefined ? _data["need_inform_by_sms"] : false;
        }
    }

    static fromJS(data: any): ContractorForm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractorForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mnemonic_name"] = this.mnemonic_name;
        data["title"] = this.title;
        data["description"] = this.description;
        data["responsible_person"] = this.responsible_person;
        data["image"] = this.image;
        data["hash_tag"] = this.hash_tag;
        data["contact_phone"] = this.contact_phone;
        data["contact_email"] = this.contact_email;
        data["pre_controller_email"] = this.pre_controller_email;
        data["telegram_chat_id"] = this.telegram_chat_id;
        data["public_website"] = this.public_website;
        data["more_info"] = this.more_info;
        data["type"] = this.type;
        if (Array.isArray(this.schedule)) {
            data["schedule"] = [];
            for (let item of this.schedule)
                data["schedule"].push(item.toJSON());
        }
        if (Array.isArray(this.problem_categories)) {
            data["problem_categories"] = [];
            for (let item of this.problem_categories)
                data["problem_categories"].push(item);
        }
        data["is_active"] = this.is_active;
        data["generate_daily_report"] = this.generate_daily_report;
        data["need_inform_by_email"] = this.need_inform_by_email;
        data["need_inform_by_sms"] = this.need_inform_by_sms;
        return data;
    }
}

export interface IContractorForm {
    /** Мнемоническое имя */
    mnemonic_name: string;
    /** Название исполнительного органа */
    title: string;
    /** Описание исполнительного органа */
    description: string;
    /** Ответственное лицо от органа исполнения  проверки */
    responsible_person: string;
    /** Изображение (аватар исполнительного органа) */
    image?: string;
    hash_tag: string;
    contact_phone: string;
    contact_email: string;
    /** электронная почта отвественного министерства */
    pre_controller_email?: string;
    /** идентификатор телеграм канала исполнительного органа */
    telegram_chat_id: string;
    /** Ссылка на веб-ресурс службы */
    public_website?: string;
    /** дополнительная информация о контролирующем \ исполнительном органе */
    more_info?: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type: ContractorFormType;
    schedule: Schedule2[];
    problem_categories: number[];
    /** Статус видимости организации в общем списке */
    is_active?: boolean;
    /** Генерировать дневные отчеты */
    generate_daily_report?: boolean;
    /** информировать по электронной почте */
    need_inform_by_email?: boolean;
    /** информировать по sms */
    need_inform_by_sms?: boolean;
}

export class ContractorTask implements IContractorTask {
    id?: number;
    request_id?: number;
    contractor_id?: number;
    request?: Request;
    contractor?: Contractor;
    /** Предполагаемая дата проведения работ  контроля  */
    estimated_task_processing_date?: string;
    /** Фактическая дата проведения работ  контроля  */
    actual_task_processing_date?: string;
    /** Пояснение исполнительного   контролирующего органа */
    description?: string;
    /** Ответственное за работу лицо от органа исполнения  проверки */
    responsible_person?: string;
    /** Номер телефона ответственного лица */
    contact_phone?: string;
    /** Адрес эл. почты ответственного лица */
    contact_email?: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type?: ContractorTaskType;
    attachments?: MediaContent[];
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IContractorTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.estimated_task_processing_date = "2022-05-05 11:00:00";
            this.actual_task_processing_date = "2022-05-05 11:00:00";
            this.type = ContractorTaskType.EXECUTIVE;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.request_id = _data["request_id"];
            this.contractor_id = _data["contractor_id"];
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.contractor = _data["contractor"] ? Contractor.fromJS(_data["contractor"]) : <any>undefined;
            this.estimated_task_processing_date = _data["estimated_task_processing_date"] !== undefined ? _data["estimated_task_processing_date"] : "2022-05-05 11:00:00";
            this.actual_task_processing_date = _data["actual_task_processing_date"] !== undefined ? _data["actual_task_processing_date"] : "2022-05-05 11:00:00";
            this.description = _data["description"];
            this.responsible_person = _data["responsible_person"];
            this.contact_phone = _data["contact_phone"];
            this.contact_email = _data["contact_email"];
            this.type = _data["type"] !== undefined ? _data["type"] : ContractorTaskType.EXECUTIVE;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): ContractorTask {
        data = typeof data === 'object' ? data : {};
        let result = new ContractorTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["request_id"] = this.request_id;
        data["contractor_id"] = this.contractor_id;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["contractor"] = this.contractor ? this.contractor.toJSON() : <any>undefined;
        data["estimated_task_processing_date"] = this.estimated_task_processing_date;
        data["actual_task_processing_date"] = this.actual_task_processing_date;
        data["description"] = this.description;
        data["responsible_person"] = this.responsible_person;
        data["contact_phone"] = this.contact_phone;
        data["contact_email"] = this.contact_email;
        data["type"] = this.type;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IContractorTask {
    id?: number;
    request_id?: number;
    contractor_id?: number;
    request?: Request;
    contractor?: Contractor;
    /** Предполагаемая дата проведения работ  контроля  */
    estimated_task_processing_date?: string;
    /** Фактическая дата проведения работ  контроля  */
    actual_task_processing_date?: string;
    /** Пояснение исполнительного   контролирующего органа */
    description?: string;
    /** Ответственное за работу лицо от органа исполнения  проверки */
    responsible_person?: string;
    /** Номер телефона ответственного лица */
    contact_phone?: string;
    /** Адрес эл. почты ответственного лица */
    contact_email?: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type?: ContractorTaskType;
    attachments?: MediaContent[];
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class ContractorTaskForm implements IContractorTaskForm {
    request_id!: number;
    contractor_id!: number;
    /** Пояснение исполнительного   контролирующего органа */
    description!: string;
    /** Ответственное за работу лицо от органа исполнения  проверки */
    responsible_person!: string;
    /** Номер телефона ответственного лица */
    contact_phone!: string;
    /** Адрес эл. почты ответственного лица */
    contact_email!: string;
    /** Предполагаемая дата проведения работ  контроля  */
    estimated_task_processing_date!: string;
    /** Фактическая дата проведения работ  контроля  */
    actual_task_processing_date!: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type!: ContractorTaskFormType;
    attachments?: MediaContent[];

    constructor(data?: IContractorTaskForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.estimated_task_processing_date = "2022-05-05 11:00:00";
            this.actual_task_processing_date = "2022-05-05 11:00:00";
            this.type = ContractorTaskFormType.EXECUTIVE;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.request_id = _data["request_id"];
            this.contractor_id = _data["contractor_id"];
            this.description = _data["description"];
            this.responsible_person = _data["responsible_person"];
            this.contact_phone = _data["contact_phone"];
            this.contact_email = _data["contact_email"];
            this.estimated_task_processing_date = _data["estimated_task_processing_date"] !== undefined ? _data["estimated_task_processing_date"] : "2022-05-05 11:00:00";
            this.actual_task_processing_date = _data["actual_task_processing_date"] !== undefined ? _data["actual_task_processing_date"] : "2022-05-05 11:00:00";
            this.type = _data["type"] !== undefined ? _data["type"] : ContractorTaskFormType.EXECUTIVE;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractorTaskForm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractorTaskForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request_id"] = this.request_id;
        data["contractor_id"] = this.contractor_id;
        data["description"] = this.description;
        data["responsible_person"] = this.responsible_person;
        data["contact_phone"] = this.contact_phone;
        data["contact_email"] = this.contact_email;
        data["estimated_task_processing_date"] = this.estimated_task_processing_date;
        data["actual_task_processing_date"] = this.actual_task_processing_date;
        data["type"] = this.type;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractorTaskForm {
    request_id: number;
    contractor_id: number;
    /** Пояснение исполнительного   контролирующего органа */
    description: string;
    /** Ответственное за работу лицо от органа исполнения  проверки */
    responsible_person: string;
    /** Номер телефона ответственного лица */
    contact_phone: string;
    /** Адрес эл. почты ответственного лица */
    contact_email: string;
    /** Предполагаемая дата проведения работ  контроля  */
    estimated_task_processing_date: string;
    /** Фактическая дата проведения работ  контроля  */
    actual_task_processing_date: string;
    /** Выбор типа организации:
 * `EXECUTIVE` - исполнительные органы
 * `SUPERVISING` - контролирующие органы
 */
    type: ContractorTaskFormType;
    attachments?: MediaContent[];
}

export class RequestByContractor implements IRequestByContractor {
    id?: number;
    contractor_id?: number;
    request_id?: number;
    /** Выбор типа задачи для органа - контроль, исполнение:
 * `EXECUTIVE` - исполнение
 * `SUPERVISING` - контроль
 */
    type?: RequestByContractorType;
    /** краткое пояснение исполнительного \ контролирующего органа */
    description?: string;
    /** медиа данные по исполнению \ контролю */
    attachments?: MediaContent[];
    /** время проведения работ \ контроля */
    worked_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IRequestByContractor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.type = RequestByContractorType.EXECUTION;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractor_id = _data["contractor_id"];
            this.request_id = _data["request_id"];
            this.type = _data["type"] !== undefined ? _data["type"] : RequestByContractorType.EXECUTION;
            this.description = _data["description"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MediaContent.fromJS(item));
            }
            this.worked_at = _data["worked_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): RequestByContractor {
        data = typeof data === 'object' ? data : {};
        let result = new RequestByContractor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractor_id"] = this.contractor_id;
        data["request_id"] = this.request_id;
        data["type"] = this.type;
        data["description"] = this.description;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["worked_at"] = this.worked_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IRequestByContractor {
    id?: number;
    contractor_id?: number;
    request_id?: number;
    /** Выбор типа задачи для органа - контроль, исполнение:
 * `EXECUTIVE` - исполнение
 * `SUPERVISING` - контроль
 */
    type?: RequestByContractorType;
    /** краткое пояснение исполнительного \ контролирующего органа */
    description?: string;
    /** медиа данные по исполнению \ контролю */
    attachments?: MediaContent[];
    /** время проведения работ \ контроля */
    worked_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class MailingQuery implements IMailingQuery {
    id?: number;
    address_to?: string;
    /** Тип рассылки:
  * `PHONE` - при помощи смс
  * `MAIL` - при помощи почты
 */
    type?: MailingQueryType;
    /** Статус отправки:
  * `SUCCESS` - успешная отправка
  * `FAILURE` - ошибка при попытке отправки
 */
    status?: MailingQueryStatus;
    /** Название шаблона для рассылки (для email) */
    template_name?: string;
    message_object?: Message_object;
    request_id?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IMailingQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address_to = _data["address_to"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.template_name = _data["template_name"];
            this.message_object = _data["message_object"] ? Message_object.fromJS(_data["message_object"]) : <any>undefined;
            this.request_id = _data["request_id"];
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): MailingQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailingQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address_to"] = this.address_to;
        data["type"] = this.type;
        data["status"] = this.status;
        data["template_name"] = this.template_name;
        data["message_object"] = this.message_object ? this.message_object.toJSON() : <any>undefined;
        data["request_id"] = this.request_id;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IMailingQuery {
    id?: number;
    address_to?: string;
    /** Тип рассылки:
  * `PHONE` - при помощи смс
  * `MAIL` - при помощи почты
 */
    type?: MailingQueryType;
    /** Статус отправки:
  * `SUCCESS` - успешная отправка
  * `FAILURE` - ошибка при попытке отправки
 */
    status?: MailingQueryStatus;
    /** Название шаблона для рассылки (для email) */
    template_name?: string;
    message_object?: Message_object;
    request_id?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class MailingQueryForm implements IMailingQueryForm {
    address_to?: string;
    /** Тип рассылки:
  * `PHONE` - при помощи смс
  * `MAIL` - при помощи почты
 */
    type?: MailingQueryFormType;
    /** Статус отправки:
  * `SUCCESS` - успешная отправка
  * `FAILURE` - ошибка при попытке отправки
 */
    status?: MailingQueryFormStatus;
    /** Название шаблона для рассылки (для email) */
    template_name?: string;
    message_object?: Message_object2;
    request_id?: number;

    constructor(data?: IMailingQueryForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address_to = _data["address_to"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.template_name = _data["template_name"];
            this.message_object = _data["message_object"] ? Message_object2.fromJS(_data["message_object"]) : <any>undefined;
            this.request_id = _data["request_id"];
        }
    }

    static fromJS(data: any): MailingQueryForm {
        data = typeof data === 'object' ? data : {};
        let result = new MailingQueryForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address_to"] = this.address_to;
        data["type"] = this.type;
        data["status"] = this.status;
        data["template_name"] = this.template_name;
        data["message_object"] = this.message_object ? this.message_object.toJSON() : <any>undefined;
        data["request_id"] = this.request_id;
        return data;
    }
}

export interface IMailingQueryForm {
    address_to?: string;
    /** Тип рассылки:
  * `PHONE` - при помощи смс
  * `MAIL` - при помощи почты
 */
    type?: MailingQueryFormType;
    /** Статус отправки:
  * `SUCCESS` - успешная отправка
  * `FAILURE` - ошибка при попытке отправки
 */
    status?: MailingQueryFormStatus;
    /** Название шаблона для рассылки (для email) */
    template_name?: string;
    message_object?: Message_object2;
    request_id?: number;
}

export class Story implements IStory {
    id?: number;
    title?: string;
    content?: string;
    /** Группа, по которой можно объединить истории под одну плитку */
    group_name?: string;
    /** Позиция в общей выдаче (позиция в рамках группы формируется по дате добавления) */
    position?: number;
    /** Имя отправителя новости */
    author?: string;
    /** Тип содержимого: * `IMAGE` - история, фоном которой является изображение * `VIDEO` - история, фоном которой является видео
 */
    content_type?: StoryContent_type;
    /** Ссылка на контента согласно типу */
    content_url?: string;
    /** Срок жизни новости */
    live_to?: string;
    /** Длительность слайда */
    duration?: number;
    /** * `INFORMATION` - информационная история (цвет зеленый) * `WARNING` - предупреждающая история (оранжевый цвет) * `DANGER` - критически важная новость (красный цвет) * `ADVERTING` - реклама (синий цвет)
 */
    story_type?: Story_type;
    /** идентификатор администратора, который добавил новость (историю) */
    moderator_id?: number;
    /** состояния активности (отображения) новости */
    is_active?: boolean;
    /** Число просмотров (расчетное поле) */
    watch_count?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IStory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_active = true;
            this.watch_count = 0;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.group_name = _data["group_name"];
            this.position = _data["position"];
            this.author = _data["author"];
            this.content_type = _data["content_type"];
            this.content_url = _data["content_url"];
            this.live_to = _data["live_to"];
            this.duration = _data["duration"];
            this.story_type = _data["story_type"];
            this.moderator_id = _data["moderator_id"];
            this.is_active = _data["is_active"] !== undefined ? _data["is_active"] : true;
            this.watch_count = _data["watch_count"] !== undefined ? _data["watch_count"] : 0;
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Story {
        data = typeof data === 'object' ? data : {};
        let result = new Story();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["group_name"] = this.group_name;
        data["position"] = this.position;
        data["author"] = this.author;
        data["content_type"] = this.content_type;
        data["content_url"] = this.content_url;
        data["live_to"] = this.live_to;
        data["duration"] = this.duration;
        data["story_type"] = this.story_type;
        data["moderator_id"] = this.moderator_id;
        data["is_active"] = this.is_active;
        data["watch_count"] = this.watch_count;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IStory {
    id?: number;
    title?: string;
    content?: string;
    /** Группа, по которой можно объединить истории под одну плитку */
    group_name?: string;
    /** Позиция в общей выдаче (позиция в рамках группы формируется по дате добавления) */
    position?: number;
    /** Имя отправителя новости */
    author?: string;
    /** Тип содержимого: * `IMAGE` - история, фоном которой является изображение * `VIDEO` - история, фоном которой является видео
 */
    content_type?: StoryContent_type;
    /** Ссылка на контента согласно типу */
    content_url?: string;
    /** Срок жизни новости */
    live_to?: string;
    /** Длительность слайда */
    duration?: number;
    /** * `INFORMATION` - информационная история (цвет зеленый) * `WARNING` - предупреждающая история (оранжевый цвет) * `DANGER` - критически важная новость (красный цвет) * `ADVERTING` - реклама (синий цвет)
 */
    story_type?: Story_type;
    /** идентификатор администратора, который добавил новость (историю) */
    moderator_id?: number;
    /** состояния активности (отображения) новости */
    is_active?: boolean;
    /** Число просмотров (расчетное поле) */
    watch_count?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class StoryForm implements IStoryForm {
    title?: string;
    content?: string;
    /** Группа, по которой можно объединить истории под одну плитку */
    group_name?: string;
    /** Позиция в общей выдаче (позиция в рамках группы формируется по дате добавления) */
    position?: number;
    /** Имя отправителя новости */
    author?: string;
    /** Тип содержимого: * `IMAGE` - история, фоном которой является изображение * `VIDEO` - история, фоном которой является видео
 */
    content_type?: StoryFormContent_type;
    /** Ссылка на контента согласно типу */
    content_url?: string;
    /** Срок жизни новости */
    live_to?: string;
    /** Длительность слайда */
    duration?: number;
    /** * `INFORMATION` - информационная история (цвет зеленый) * `WARNING` - предупреждающая история (оранжевый цвет) * `DANGER` - критически важная новость (красный цвет) * `ADVERTING` - реклама (синий цвет)
 */
    story_type?: StoryFormStory_type;
    /** идентификатор администратора, который добавил новость (историю) */
    moderator_id?: number;
    /** состояния активности (отображения) новости */
    is_active?: boolean;

    constructor(data?: IStoryForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_active = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
            this.group_name = _data["group_name"];
            this.position = _data["position"];
            this.author = _data["author"];
            this.content_type = _data["content_type"];
            this.content_url = _data["content_url"];
            this.live_to = _data["live_to"];
            this.duration = _data["duration"];
            this.story_type = _data["story_type"];
            this.moderator_id = _data["moderator_id"];
            this.is_active = _data["is_active"] !== undefined ? _data["is_active"] : true;
        }
    }

    static fromJS(data: any): StoryForm {
        data = typeof data === 'object' ? data : {};
        let result = new StoryForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        data["group_name"] = this.group_name;
        data["position"] = this.position;
        data["author"] = this.author;
        data["content_type"] = this.content_type;
        data["content_url"] = this.content_url;
        data["live_to"] = this.live_to;
        data["duration"] = this.duration;
        data["story_type"] = this.story_type;
        data["moderator_id"] = this.moderator_id;
        data["is_active"] = this.is_active;
        return data;
    }
}

export interface IStoryForm {
    title?: string;
    content?: string;
    /** Группа, по которой можно объединить истории под одну плитку */
    group_name?: string;
    /** Позиция в общей выдаче (позиция в рамках группы формируется по дате добавления) */
    position?: number;
    /** Имя отправителя новости */
    author?: string;
    /** Тип содержимого: * `IMAGE` - история, фоном которой является изображение * `VIDEO` - история, фоном которой является видео
 */
    content_type?: StoryFormContent_type;
    /** Ссылка на контента согласно типу */
    content_url?: string;
    /** Срок жизни новости */
    live_to?: string;
    /** Длительность слайда */
    duration?: number;
    /** * `INFORMATION` - информационная история (цвет зеленый) * `WARNING` - предупреждающая история (оранжевый цвет) * `DANGER` - критически важная новость (красный цвет) * `ADVERTING` - реклама (синий цвет)
 */
    story_type?: StoryFormStory_type;
    /** идентификатор администратора, который добавил новость (историю) */
    moderator_id?: number;
    /** состояния активности (отображения) новости */
    is_active?: boolean;
}

export class Region implements IRegion {
    id?: number;
    title?: string;
    /** Позиция региона в списке */
    positions?: number;
    /** состояния активности региона */
    is_active?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_active = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.positions = _data["positions"];
            this.is_active = _data["is_active"] !== undefined ? _data["is_active"] : true;
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["positions"] = this.positions;
        data["is_active"] = this.is_active;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IRegion {
    id?: number;
    title?: string;
    /** Позиция региона в списке */
    positions?: number;
    /** состояния активности региона */
    is_active?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class RegionForm implements IRegionForm {
    id?: number;
    title?: string;
    /** Позиция региона в списке */
    positions?: number;
    /** состояния активности региона */
    is_active?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IRegionForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_active = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.positions = _data["positions"];
            this.is_active = _data["is_active"] !== undefined ? _data["is_active"] : true;
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): RegionForm {
        data = typeof data === 'object' ? data : {};
        let result = new RegionForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["positions"] = this.positions;
        data["is_active"] = this.is_active;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IRegionForm {
    id?: number;
    title?: string;
    /** Позиция региона в списке */
    positions?: number;
    /** состояния активности региона */
    is_active?: boolean;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class StoppingPoint implements IStoppingPoint {
    id?: number;
    /** Название остановочного пункта */
    title?: string;
    /** название управляющего предприятия */
    manager_company?: string;
    /** город \ поселок \ село где расположен остановочный пункт */
    city?: string;
    route?: TransportRoutes;
    latitude?: number;
    longitude?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: IStoppingPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.latitude = 0;
            this.longitude = 0;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.manager_company = _data["manager_company"];
            this.city = _data["city"];
            this.route = _data["route"] ? TransportRoutes.fromJS(_data["route"]) : <any>undefined;
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : 0;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : 0;
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): StoppingPoint {
        data = typeof data === 'object' ? data : {};
        let result = new StoppingPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["manager_company"] = this.manager_company;
        data["city"] = this.city;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IStoppingPoint {
    id?: number;
    /** Название остановочного пункта */
    title?: string;
    /** название управляющего предприятия */
    manager_company?: string;
    /** город \ поселок \ село где расположен остановочный пункт */
    city?: string;
    route?: TransportRoutes;
    latitude?: number;
    longitude?: number;
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class StoppingPointForm implements IStoppingPointForm {
    /** Название остановочного пункта */
    title?: string;
    /** название управляющего предприятия */
    manager_company?: string;
    /** город \ поселок \ село где расположен остановочный пункт */
    city?: string;
    latitude?: number;
    longitude?: number;

    constructor(data?: IStoppingPointForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.latitude = 0;
            this.longitude = 0;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.manager_company = _data["manager_company"];
            this.city = _data["city"];
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : 0;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : 0;
        }
    }

    static fromJS(data: any): StoppingPointForm {
        data = typeof data === 'object' ? data : {};
        let result = new StoppingPointForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["manager_company"] = this.manager_company;
        data["city"] = this.city;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IStoppingPointForm {
    /** Название остановочного пункта */
    title?: string;
    /** название управляющего предприятия */
    manager_company?: string;
    /** город \ поселок \ село где расположен остановочный пункт */
    city?: string;
    latitude?: number;
    longitude?: number;
}

export class TransportRoutes implements ITransportRoutes {
    id?: number;
    /** Название маршрута */
    title?: string;
    /** номер маршрута */
    route_number?: string;
    /** Номер машины */
    car_number?: string;
    drivers_on_route?: User[];
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;

    constructor(data?: ITransportRoutes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.route_number = _data["route_number"];
            this.car_number = _data["car_number"];
            if (Array.isArray(_data["drivers_on_route"])) {
                this.drivers_on_route = [] as any;
                for (let item of _data["drivers_on_route"])
                    this.drivers_on_route!.push(User.fromJS(item));
            }
            this.deleted_at = _data["deleted_at"];
            this.created_at = _data["created_at"];
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): TransportRoutes {
        data = typeof data === 'object' ? data : {};
        let result = new TransportRoutes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["route_number"] = this.route_number;
        data["car_number"] = this.car_number;
        if (Array.isArray(this.drivers_on_route)) {
            data["drivers_on_route"] = [];
            for (let item of this.drivers_on_route)
                data["drivers_on_route"].push(item.toJSON());
        }
        data["deleted_at"] = this.deleted_at;
        data["created_at"] = this.created_at;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface ITransportRoutes {
    id?: number;
    /** Название маршрута */
    title?: string;
    /** номер маршрута */
    route_number?: string;
    /** Номер машины */
    car_number?: string;
    drivers_on_route?: User[];
    deleted_at?: string;
    created_at?: string;
    updated_at?: string;
}

export class TransportRoutesForm implements ITransportRoutesForm {
    /** Название маршрута */
    title?: string;
    /** номер маршрута */
    route_number?: string;
    /** идентификаторы пользователей-водителей на указанном маршруте */
    drivers_user_ids?: number[];
    /** Номер машины */
    car_number?: string;

    constructor(data?: ITransportRoutesForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.route_number = _data["route_number"];
            if (Array.isArray(_data["drivers_user_ids"])) {
                this.drivers_user_ids = [] as any;
                for (let item of _data["drivers_user_ids"])
                    this.drivers_user_ids!.push(item);
            }
            this.car_number = _data["car_number"];
        }
    }

    static fromJS(data: any): TransportRoutesForm {
        data = typeof data === 'object' ? data : {};
        let result = new TransportRoutesForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["route_number"] = this.route_number;
        if (Array.isArray(this.drivers_user_ids)) {
            data["drivers_user_ids"] = [];
            for (let item of this.drivers_user_ids)
                data["drivers_user_ids"].push(item);
        }
        data["car_number"] = this.car_number;
        return data;
    }
}

export interface ITransportRoutesForm {
    /** Название маршрута */
    title?: string;
    /** номер маршрута */
    route_number?: string;
    /** идентификаторы пользователей-водителей на указанном маршруте */
    drivers_user_ids?: number[];
    /** Номер машины */
    car_number?: string;
}

export class Body implements IBody {
    name?: string;
    username?: string;
    password?: string;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IBody {
    name?: string;
    username?: string;
    password?: string;
}

export class Body2 implements IBody2 {
    username?: string;
    password?: string;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IBody2 {
    username?: string;
    password?: string;
}

export class Body3 implements IBody3 {
    refreshToken?: string;

    constructor(data?: IBody3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): Body3 {
        data = typeof data === 'object' ? data : {};
        let result = new Body3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IBody3 {
    refreshToken?: string;
}

export class Body4 implements IBody4 {
    username?: string;

    constructor(data?: IBody4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): Body4 {
        data = typeof data === 'object' ? data : {};
        let result = new Body4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        return data;
    }
}

export interface IBody4 {
    username?: string;
}

export class Body5 implements IBody5 {
    newPassword?: string;
    token?: string;

    constructor(data?: IBody5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): Body5 {
        data = typeof data === 'object' ? data : {};
        let result = new Body5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["token"] = this.token;
        return data;
    }
}

export interface IBody5 {
    newPassword?: string;
    token?: string;
}

export class Body6 implements IBody6 {
    newPassword?: string;
    oldPassword?: string;

    constructor(data?: IBody6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): Body6 {
        data = typeof data === 'object' ? data : {};
        let result = new Body6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IBody6 {
    newPassword?: string;
    oldPassword?: string;
}

export class Body7 implements IBody7 {
    latitude?: string;
    longitude?: string;

    constructor(data?: IBody7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): Body7 {
        data = typeof data === 'object' ? data : {};
        let result = new Body7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IBody7 {
    latitude?: string;
    longitude?: string;
}

export class Body8 implements IBody8 {
    address?: string;

    constructor(data?: IBody8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): Body8 {
        data = typeof data === 'object' ? data : {};
        let result = new Body8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        return data;
    }
}

export interface IBody8 {
    address?: string;
}

export enum Level {
    INFO = "INFO",
    DANGER = "DANGER",
    WARNING = "WARNING",
}

export enum Type {
    COORDS_ALERT = "COORDS_ALERT",
    TEXT = "TEXT",
}

export enum Send_as {
    AS_NOTIFICATION = "AS_NOTIFICATION",
    AS_EMAIL = "AS_EMAIL",
    AS_EMAIL_AND_NOTIFICATION = "AS_EMAIL_AND_NOTIFICATION",
    AS_SMS = "AS_SMS",
    ALL = "ALL",
}

export enum Category {
    SELECTED_USERS = "SELECTED_USERS",
    ONLY_USERS = "ONLY_USERS",
    ALL = "ALL",
    ONLY_ACTIVE_REQUEST = "ONLY_ACTIVE_REQUEST",
    ONLY_ARCHIVE_REQUEST = "ONLY_ARCHIVE_REQUEST",
    ONLY_CONTRACTORS = "ONLY_CONTRACTORS",
    ONLY_CONTRACTORS_EXECUTIVE = "ONLY_CONTRACTORS_EXECUTIVE",
    ONLY_CONTRACTORS_SUPERVISING = "ONLY_CONTRACTORS_SUPERVISING",
}

export class Body9 implements IBody9 {
    start_at?: string;
    end_at?: string;
    object_id?: number[];
    /** Статистика по:
  * `REQUEST_BY_CATEGORIES` - запросы по категориям
  * `REQUEST_BY_CONTRACTORS` - запросы по исполнительным \ контролирующим органам
  * `REQUEST_BY_CONTRACTORS_EXECUTIVE` - запросы по исполнительным  органам
  * `REQUEST_BY_CONTRACTORS_SUPERVISING` - запросы по контролирующим органам
  * `CONTRACTORS` - добавленные исполнительные \ контролирующие органы
  * `ACCEPTED_REQUESTS` - принятые в работу заявки
  * `DECLINE_REQUESTS` - отклоненные заявки
  * `SUMMARY_ALL` - суммарная сводка по заявкам
  * `NEW_USERS` - новые пользователи
  * `ACTIVE_USERS` - активные пользователи
 */
    object_type?: Body9Object_type;

    constructor(data?: IBody9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start_at = _data["start_at"];
            this.end_at = _data["end_at"];
            if (Array.isArray(_data["object_id"])) {
                this.object_id = [] as any;
                for (let item of _data["object_id"])
                    this.object_id!.push(item);
            }
            this.object_type = _data["object_type"];
        }
    }

    static fromJS(data: any): Body9 {
        data = typeof data === 'object' ? data : {};
        let result = new Body9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start_at"] = this.start_at;
        data["end_at"] = this.end_at;
        if (Array.isArray(this.object_id)) {
            data["object_id"] = [];
            for (let item of this.object_id)
                data["object_id"].push(item);
        }
        data["object_type"] = this.object_type;
        return data;
    }
}

export interface IBody9 {
    start_at?: string;
    end_at?: string;
    object_id?: number[];
    /** Статистика по:
  * `REQUEST_BY_CATEGORIES` - запросы по категориям
  * `REQUEST_BY_CONTRACTORS` - запросы по исполнительным \ контролирующим органам
  * `REQUEST_BY_CONTRACTORS_EXECUTIVE` - запросы по исполнительным  органам
  * `REQUEST_BY_CONTRACTORS_SUPERVISING` - запросы по контролирующим органам
  * `CONTRACTORS` - добавленные исполнительные \ контролирующие органы
  * `ACCEPTED_REQUESTS` - принятые в работу заявки
  * `DECLINE_REQUESTS` - отклоненные заявки
  * `SUMMARY_ALL` - суммарная сводка по заявкам
  * `NEW_USERS` - новые пользователи
  * `ACTIVE_USERS` - активные пользователи
 */
    object_type?: Body9Object_type;
}

export class Body10 implements IBody10 {
    start_at?: string;
    end_at?: string;
    category_id?: number[];
    /** Радиус, в котором отображается тепловая карта */
    radius?: number;
    /** широта */
    latitude?: number;
    /** долгота */
    longitude?: number;
    /** Тепловая карта заявок:
  * `ACCEPTED` - принятые запросы
  * `RESOLVED` - выполненные запросы
  * `NOT_ACCEPTED` - не принятые запросы
  * `DECLINED` - отклоненные запрос
 */
    type?: Body10Type;

    constructor(data?: IBody10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start_at = _data["start_at"];
            this.end_at = _data["end_at"];
            if (Array.isArray(_data["category_id"])) {
                this.category_id = [] as any;
                for (let item of _data["category_id"])
                    this.category_id!.push(item);
            }
            this.radius = _data["radius"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Body10 {
        data = typeof data === 'object' ? data : {};
        let result = new Body10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start_at"] = this.start_at;
        data["end_at"] = this.end_at;
        if (Array.isArray(this.category_id)) {
            data["category_id"] = [];
            for (let item of this.category_id)
                data["category_id"].push(item);
        }
        data["radius"] = this.radius;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["type"] = this.type;
        return data;
    }
}

export interface IBody10 {
    start_at?: string;
    end_at?: string;
    category_id?: number[];
    /** Радиус, в котором отображается тепловая карта */
    radius?: number;
    /** широта */
    latitude?: number;
    /** долгота */
    longitude?: number;
    /** Тепловая карта заявок:
  * `ACCEPTED` - принятые запросы
  * `RESOLVED` - выполненные запросы
  * `NOT_ACCEPTED` - не принятые запросы
  * `DECLINED` - отклоненные запрос
 */
    type?: Body10Type;
}

export class Body11 implements IBody11 {
    start_at?: string;
    end_at?: string;
    category_id?: number[];
    /** Экспорт заявок по типу:
  * `ACCEPTED` - принятые запросы
  * `RESOLVED` - выполненные запросы
  * `NOT_ACCEPTED` - не принятые запросы
  * `DECLINED` - отклоненные запрос
 */
    type?: Body11Type;

    constructor(data?: IBody11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start_at = _data["start_at"];
            this.end_at = _data["end_at"];
            if (Array.isArray(_data["category_id"])) {
                this.category_id = [] as any;
                for (let item of _data["category_id"])
                    this.category_id!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Body11 {
        data = typeof data === 'object' ? data : {};
        let result = new Body11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start_at"] = this.start_at;
        data["end_at"] = this.end_at;
        if (Array.isArray(this.category_id)) {
            data["category_id"] = [];
            for (let item of this.category_id)
                data["category_id"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

export interface IBody11 {
    start_at?: string;
    end_at?: string;
    category_id?: number[];
    /** Экспорт заявок по типу:
  * `ACCEPTED` - принятые запросы
  * `RESOLVED` - выполненные запросы
  * `NOT_ACCEPTED` - не принятые запросы
  * `DECLINED` - отклоненные запрос
 */
    type?: Body11Type;
}

export class Body12 implements IBody12 {
    role_ids?: number[];

    constructor(data?: IBody12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["role_ids"])) {
                this.role_ids = [] as any;
                for (let item of _data["role_ids"])
                    this.role_ids!.push(item);
            }
        }
    }

    static fromJS(data: any): Body12 {
        data = typeof data === 'object' ? data : {};
        let result = new Body12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.role_ids)) {
            data["role_ids"] = [];
            for (let item of this.role_ids)
                data["role_ids"].push(item);
        }
        return data;
    }
}

export interface IBody12 {
    role_ids?: number[];
}

export class Body13 implements IBody13 {
    /** радиус охвата заявок */
    distance?: number;
    longitude?: number;
    latitude?: number;

    constructor(data?: IBody13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.distance = 50;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.distance = _data["distance"] !== undefined ? _data["distance"] : 50;
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): Body13 {
        data = typeof data === 'object' ? data : {};
        let result = new Body13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["distance"] = this.distance;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export interface IBody13 {
    /** радиус охвата заявок */
    distance?: number;
    longitude?: number;
    latitude?: number;
}

export class Body14 implements IBody14 {
    /** рейтинг заявки (может быть в плюс и в минус) */
    rating?: number;
    request_id?: number;

    constructor(data?: IBody14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.rating = 50;
            this.request_id = 1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rating = _data["rating"] !== undefined ? _data["rating"] : 50;
            this.request_id = _data["request_id"] !== undefined ? _data["request_id"] : 1;
        }
    }

    static fromJS(data: any): Body14 {
        data = typeof data === 'object' ? data : {};
        let result = new Body14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rating"] = this.rating;
        data["request_id"] = this.request_id;
        return data;
    }
}

export interface IBody14 {
    /** рейтинг заявки (может быть в плюс и в минус) */
    rating?: number;
    request_id?: number;
}

export class Anonymous implements IAnonymous {
    accessToken?: string;
    refreshToken?: string;
    tokenType?: string;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.tokenType = _data["tokenType"];
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["tokenType"] = this.tokenType;
        return data;
    }
}

export interface IAnonymous {
    accessToken?: string;
    refreshToken?: string;
    tokenType?: string;
}

export class Anonymous2 implements IAnonymous2 {
    accessToken?: string;
    refreshToken?: string;
    tokenType?: string;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.tokenType = _data["tokenType"];
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["tokenType"] = this.tokenType;
        return data;
    }
}

export interface IAnonymous2 {
    accessToken?: string;
    refreshToken?: string;
    tokenType?: string;
}

export class Anonymous3 implements IAnonymous3 {
    address?: string;

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): Anonymous3 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        return data;
    }
}

export interface IAnonymous3 {
    address?: string;
}

export class Anonymous4 implements IAnonymous4 {
    latitude?: string;
    longitude?: string;

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): Anonymous4 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IAnonymous4 {
    latitude?: string;
    longitude?: string;
}

export class Anonymous5 implements IAnonymous5 {
    latitude?: string;
    longitude?: string;

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): Anonymous5 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IAnonymous5 {
    latitude?: string;
    longitude?: string;
}

export class Anonymous6 implements IAnonymous6 {
    heat_map_data?: Heat_map_data[];

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["heat_map_data"])) {
                this.heat_map_data = [] as any;
                for (let item of _data["heat_map_data"])
                    this.heat_map_data!.push(Heat_map_data.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous6 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.heat_map_data)) {
            data["heat_map_data"] = [];
            for (let item of this.heat_map_data)
                data["heat_map_data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAnonymous6 {
    heat_map_data?: Heat_map_data[];
}

export class Anonymous7 extends PaginateObject implements IAnonymous7 {
    data?: User[];

    constructor(data?: IAnonymous7) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous7 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous7 extends IPaginateObject {
    data?: User[];
}

export class Anonymous8 extends PaginateObject implements IAnonymous8 {
    data?: Profile[];

    constructor(data?: IAnonymous8) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Profile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous8 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous8 extends IPaginateObject {
    data?: Profile[];
}

export class Anonymous9 extends PaginateObject implements IAnonymous9 {
    data?: ProblemCategory[];

    constructor(data?: IAnonymous9) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProblemCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous9 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous9 extends IPaginateObject {
    data?: ProblemCategory[];
}

export class Anonymous10 extends PaginateObject implements IAnonymous10 {
    data?: Request[];

    constructor(data?: IAnonymous10) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous10 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous10 extends IPaginateObject {
    data?: Request[];
}

export class Anonymous11 extends PaginateObject implements IAnonymous11 {
    data?: Request[];

    constructor(data?: IAnonymous11) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous11 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous11 extends IPaginateObject {
    data?: Request[];
}

export class Anonymous12 extends PaginateObject implements IAnonymous12 {
    data?: Request[];

    constructor(data?: IAnonymous12) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous12 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous12 extends IPaginateObject {
    data?: Request[];
}

export class Anonymous13 extends PaginateObject implements IAnonymous13 {
    data?: Request[];

    constructor(data?: IAnonymous13) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous13 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous13 extends IPaginateObject {
    data?: Request[];
}

export class Anonymous14 extends PaginateObject implements IAnonymous14 {
    data?: Request[];

    constructor(data?: IAnonymous14) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous14 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous14 extends IPaginateObject {
    data?: Request[];
}

export class Anonymous15 extends PaginateObject implements IAnonymous15 {
    data?: Request[];

    constructor(data?: IAnonymous15) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous15 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous15 extends IPaginateObject {
    data?: Request[];
}

export class Anonymous16 extends PaginateObject implements IAnonymous16 {
    data?: Contractor[];

    constructor(data?: IAnonymous16) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Contractor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous16 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous16 extends IPaginateObject {
    data?: Contractor[];
}

export class Anonymous17 extends PaginateObject implements IAnonymous17 {
    data?: StoredRequest[];

    constructor(data?: IAnonymous17) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(StoredRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous17 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous17 extends IPaginateObject {
    data?: StoredRequest[];
}

export class Anonymous18 extends PaginateObject implements IAnonymous18 {
    data?: Role[];

    constructor(data?: IAnonymous18) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous18 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous18 extends IPaginateObject {
    data?: Role[];
}

export class Anonymous19 extends PaginateObject implements IAnonymous19 {
    data?: MailingQuery[];

    constructor(data?: IAnonymous19) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MailingQuery.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous19 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous19 extends IPaginateObject {
    data?: MailingQuery[];
}

export class Anonymous20 extends PaginateObject implements IAnonymous20 {
    data?: ContractorTask[];

    constructor(data?: IAnonymous20) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ContractorTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous20 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous20 extends IPaginateObject {
    data?: ContractorTask[];
}

export class Anonymous21 extends PaginateObject implements IAnonymous21 {
    data?: Story[];

    constructor(data?: IAnonymous21) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Story.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous21 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous21 extends IPaginateObject {
    data?: Story[];
}

export class Anonymous22 extends PaginateObject implements IAnonymous22 {
    data?: Region[];

    constructor(data?: IAnonymous22) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Region.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous22 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous22();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous22 extends IPaginateObject {
    data?: Region[];
}

export enum RoleTitle {
    GUEST = "GUEST",
    USER = "USER",
    ADMINISTRATOR = "ADMINISTRATOR",
    CONTRACTOR = "CONTRACTOR",
    CONTRACTOR_EXECUTIVE = "CONTRACTOR_EXECUTIVE",
    CONTRACTOR_SUPERVISING = "CONTRACTOR_SUPERVISING",
    TECHNICAL = "TECHNICAL",
}

export enum RoleFormTitle {
    GUEST = "GUEST",
    USER = "USER",
    ADMINISTRATOR = "ADMINISTRATOR",
    CONTRACTOR = "CONTRACTOR",
    CONTRACTOR_EXECUTIVE = "CONTRACTOR_EXECUTIVE",
    CONTRACTOR_SUPERVISING = "CONTRACTOR_SUPERVISING",
    TECHNICAL = "TECHNICAL",
}

export enum RequestSource {
    LANDING = "LANDING",
    VK = "VK",
    OPERATOR = "OPERATOR",
    EXCEL = "EXCEL",
    TELEGRAM = "TELEGRAM",
    ANDROID = "ANDROID",
    IOS = "IOS",
    OTHER = "OTHER",
}

export enum RequestStatus {
    IN_PROCESSING = "IN PROCESSING",
    IN_CONSIDERATION = "IN CONSIDERATION",
    IN_EXECUTION = "IN EXECUTION",
    IN_EXECUTION_CHECK = "IN EXECUTION CHECK",
    COMPLETED = "COMPLETED",
    ARCHIVED = "ARCHIVED",
}

export class Stored_profile_data implements IStored_profile_data {
    full_name?: string;
    location?: string;
    phone?: string;
    /** персональный рейтинг пользователя на момент обращения */
    rating?: number;
    email?: string;

    constructor(data?: IStored_profile_data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.full_name = _data["full_name"];
            this.location = _data["location"];
            this.phone = _data["phone"];
            this.rating = _data["rating"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): Stored_profile_data {
        data = typeof data === 'object' ? data : {};
        let result = new Stored_profile_data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["full_name"] = this.full_name;
        data["location"] = this.location;
        data["phone"] = this.phone;
        data["rating"] = this.rating;
        data["email"] = this.email;
        return data;
    }
}

export interface IStored_profile_data {
    full_name?: string;
    location?: string;
    phone?: string;
    /** персональный рейтинг пользователя на момент обращения */
    rating?: number;
    email?: string;
}

export enum RequestFormSource {
    LANDING = "LANDING",
    VK = "VK",
    OPERATOR = "OPERATOR",
    EXCEL = "EXCEL",
    TELEGRAM = "TELEGRAM",
    ANDROID = "ANDROID",
    IOS = "IOS",
    OTHER = "OTHER",
}

export enum RequestFormStatus {
    IN_PROCESSING = "IN PROCESSING",
    IN_CONSIDERATION = "IN CONSIDERATION",
    IN_EXECUTION = "IN EXECUTION",
    IN_EXECUTION_CHECK = "IN EXECUTION CHECK",
    COMPLETED = "COMPLETED",
}

export enum MediaContentType {
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
}

export class Links implements ILinks {
    first?: string;
    last?: string;
    prev?: string;
    next?: string;

    constructor(data?: ILinks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.first = _data["first"];
            this.last = _data["last"];
            this.prev = _data["prev"];
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): Links {
        data = typeof data === 'object' ? data : {};
        let result = new Links();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first;
        data["last"] = this.last;
        data["prev"] = this.prev;
        data["next"] = this.next;
        return data;
    }
}

export interface ILinks {
    first?: string;
    last?: string;
    prev?: string;
    next?: string;
}

export enum ContractorType {
    EXECUTIVE = "EXECUTIVE",
    SUPERVISING = "SUPERVISING",
}

export class Schedule implements ISchedule {
    title?: string;
    day_index?: string;
    start_at?: string;
    end_at?: string;
    is_day_of?: boolean;
    description?: string;

    constructor(data?: ISchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_day_of = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.day_index = _data["day_index"];
            this.start_at = _data["start_at"];
            this.end_at = _data["end_at"];
            this.is_day_of = _data["is_day_of"] !== undefined ? _data["is_day_of"] : false;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["day_index"] = this.day_index;
        data["start_at"] = this.start_at;
        data["end_at"] = this.end_at;
        data["is_day_of"] = this.is_day_of;
        data["description"] = this.description;
        return data;
    }
}

export interface ISchedule {
    title?: string;
    day_index?: string;
    start_at?: string;
    end_at?: string;
    is_day_of?: boolean;
    description?: string;
}

export enum ContractorFormType {
    EXECUTIVE = "EXECUTIVE",
    SUPERVISING = "SUPERVISING",
}

export class Schedule2 implements ISchedule2 {
    title?: string;
    day_index?: string;
    start_at?: string;
    end_at?: string;
    is_day_of?: boolean;
    description?: string;

    constructor(data?: ISchedule2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_day_of = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.day_index = _data["day_index"];
            this.start_at = _data["start_at"];
            this.end_at = _data["end_at"];
            this.is_day_of = _data["is_day_of"] !== undefined ? _data["is_day_of"] : false;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Schedule2 {
        data = typeof data === 'object' ? data : {};
        let result = new Schedule2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["day_index"] = this.day_index;
        data["start_at"] = this.start_at;
        data["end_at"] = this.end_at;
        data["is_day_of"] = this.is_day_of;
        data["description"] = this.description;
        return data;
    }
}

export interface ISchedule2 {
    title?: string;
    day_index?: string;
    start_at?: string;
    end_at?: string;
    is_day_of?: boolean;
    description?: string;
}

export enum ContractorTaskType {
    EXECUTIVE = "EXECUTIVE",
    SUPERVISING = "SUPERVISING",
}

export enum ContractorTaskFormType {
    EXECUTIVE = "EXECUTIVE",
    SUPERVISING = "SUPERVISING",
}

export enum RequestByContractorType {
    VERIFICATION = "VERIFICATION",
    EXECUTION = "EXECUTION",
}

export enum MailingQueryType {
    PHONE = "PHONE",
    MAIL = "MAIL",
}

export enum MailingQueryStatus {
    SUCCESS = "SUCCESS",
    FAILURE = "FAILURE",
}

export class Message_object implements IMessage_object {
    title?: string;
    message?: string;
    author?: string;

    constructor(data?: IMessage_object) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.message = _data["message"];
            this.author = _data["author"];
        }
    }

    static fromJS(data: any): Message_object {
        data = typeof data === 'object' ? data : {};
        let result = new Message_object();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["message"] = this.message;
        data["author"] = this.author;
        return data;
    }
}

export interface IMessage_object {
    title?: string;
    message?: string;
    author?: string;
}

export enum MailingQueryFormType {
    PHONE = "PHONE",
    MAIL = "MAIL",
}

export enum MailingQueryFormStatus {
    SUCCESS = "SUCCESS",
    FAILURE = "FAILURE",
}

export class Message_object2 implements IMessage_object2 {
    title?: string;
    message?: string;
    author?: string;

    constructor(data?: IMessage_object2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.message = _data["message"];
            this.author = _data["author"];
        }
    }

    static fromJS(data: any): Message_object2 {
        data = typeof data === 'object' ? data : {};
        let result = new Message_object2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["message"] = this.message;
        data["author"] = this.author;
        return data;
    }
}

export interface IMessage_object2 {
    title?: string;
    message?: string;
    author?: string;
}

export enum StoryContent_type {
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
}

export enum Story_type {
    INFORMATION = "INFORMATION",
    WARNING = "WARNING",
    DANGER = "DANGER",
    ADVERTING = "ADVERTING",
}

export enum StoryFormContent_type {
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
}

export enum StoryFormStory_type {
    INFORMATION = "INFORMATION",
    WARNING = "WARNING",
    DANGER = "DANGER",
    ADVERTING = "ADVERTING",
}

export enum Body9Object_type {
    REQUEST_BY_CATEGORIES = "REQUEST_BY_CATEGORIES",
    REQUEST_BY_CONTRACTORS = "REQUEST_BY_CONTRACTORS",
    REQUEST_BY_CONTRACTORS_EXECUTIVE = "REQUEST_BY_CONTRACTORS_EXECUTIVE",
    REQUEST_BY_CONTRACTORS_SUPERVISING = "REQUEST_BY_CONTRACTORS_SUPERVISING",
    CONTRACTORS = "CONTRACTORS",
    ACCEPTED_REQUESTS = "ACCEPTED_REQUESTS",
    DECLINE_REQUESTS = "DECLINE_REQUESTS",
    SUMMARY_ALL = "SUMMARY_ALL",
    NEW_USERS = "NEW_USERS",
    ACTIVE_USERS = "ACTIVE_USERS",
}

export enum Body10Type {
    ACCEPTED = "ACCEPTED",
    RESOLVED = "RESOLVED",
    NOT_ACCEPTED = "NOT_ACCEPTED",
    DECLINED = "DECLINED",
}

export enum Body11Type {
    ACCEPTED = "ACCEPTED",
    RESOLVED = "RESOLVED",
    NOT_ACCEPTED = "NOT_ACCEPTED",
    DECLINED = "DECLINED",
}

export class Heat_map_data implements IHeat_map_data {
    weight?: number;
    latitude?: number;
    longitude?: number;

    constructor(data?: IHeat_map_data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weight = _data["weight"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): Heat_map_data {
        data = typeof data === 'object' ? data : {};
        let result = new Heat_map_data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weight"] = this.weight;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IHeat_map_data {
    weight?: number;
    latitude?: number;
    longitude?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}